// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: demo.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_demo_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_demo_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_demo_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_demo_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_demo_2eproto;
namespace oteldemo {
class Ad;
struct AdDefaultTypeInternal;
extern AdDefaultTypeInternal _Ad_default_instance_;
class AdRequest;
struct AdRequestDefaultTypeInternal;
extern AdRequestDefaultTypeInternal _AdRequest_default_instance_;
class AdResponse;
struct AdResponseDefaultTypeInternal;
extern AdResponseDefaultTypeInternal _AdResponse_default_instance_;
class AddItemRequest;
struct AddItemRequestDefaultTypeInternal;
extern AddItemRequestDefaultTypeInternal _AddItemRequest_default_instance_;
class Address;
struct AddressDefaultTypeInternal;
extern AddressDefaultTypeInternal _Address_default_instance_;
class Cart;
struct CartDefaultTypeInternal;
extern CartDefaultTypeInternal _Cart_default_instance_;
class CartItem;
struct CartItemDefaultTypeInternal;
extern CartItemDefaultTypeInternal _CartItem_default_instance_;
class ChargeRequest;
struct ChargeRequestDefaultTypeInternal;
extern ChargeRequestDefaultTypeInternal _ChargeRequest_default_instance_;
class ChargeResponse;
struct ChargeResponseDefaultTypeInternal;
extern ChargeResponseDefaultTypeInternal _ChargeResponse_default_instance_;
class CreateFlagRequest;
struct CreateFlagRequestDefaultTypeInternal;
extern CreateFlagRequestDefaultTypeInternal _CreateFlagRequest_default_instance_;
class CreateFlagResponse;
struct CreateFlagResponseDefaultTypeInternal;
extern CreateFlagResponseDefaultTypeInternal _CreateFlagResponse_default_instance_;
class CreditCardInfo;
struct CreditCardInfoDefaultTypeInternal;
extern CreditCardInfoDefaultTypeInternal _CreditCardInfo_default_instance_;
class CurrencyConversionRequest;
struct CurrencyConversionRequestDefaultTypeInternal;
extern CurrencyConversionRequestDefaultTypeInternal _CurrencyConversionRequest_default_instance_;
class DeleteFlagRequest;
struct DeleteFlagRequestDefaultTypeInternal;
extern DeleteFlagRequestDefaultTypeInternal _DeleteFlagRequest_default_instance_;
class DeleteFlagResponse;
struct DeleteFlagResponseDefaultTypeInternal;
extern DeleteFlagResponseDefaultTypeInternal _DeleteFlagResponse_default_instance_;
class Empty;
struct EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class EmptyCartRequest;
struct EmptyCartRequestDefaultTypeInternal;
extern EmptyCartRequestDefaultTypeInternal _EmptyCartRequest_default_instance_;
class Flag;
struct FlagDefaultTypeInternal;
extern FlagDefaultTypeInternal _Flag_default_instance_;
class GetCartRequest;
struct GetCartRequestDefaultTypeInternal;
extern GetCartRequestDefaultTypeInternal _GetCartRequest_default_instance_;
class GetFlagRequest;
struct GetFlagRequestDefaultTypeInternal;
extern GetFlagRequestDefaultTypeInternal _GetFlagRequest_default_instance_;
class GetFlagResponse;
struct GetFlagResponseDefaultTypeInternal;
extern GetFlagResponseDefaultTypeInternal _GetFlagResponse_default_instance_;
class GetProductRequest;
struct GetProductRequestDefaultTypeInternal;
extern GetProductRequestDefaultTypeInternal _GetProductRequest_default_instance_;
class GetQuoteRequest;
struct GetQuoteRequestDefaultTypeInternal;
extern GetQuoteRequestDefaultTypeInternal _GetQuoteRequest_default_instance_;
class GetQuoteResponse;
struct GetQuoteResponseDefaultTypeInternal;
extern GetQuoteResponseDefaultTypeInternal _GetQuoteResponse_default_instance_;
class GetSupportedCurrenciesResponse;
struct GetSupportedCurrenciesResponseDefaultTypeInternal;
extern GetSupportedCurrenciesResponseDefaultTypeInternal _GetSupportedCurrenciesResponse_default_instance_;
class ListFlagsRequest;
struct ListFlagsRequestDefaultTypeInternal;
extern ListFlagsRequestDefaultTypeInternal _ListFlagsRequest_default_instance_;
class ListFlagsResponse;
struct ListFlagsResponseDefaultTypeInternal;
extern ListFlagsResponseDefaultTypeInternal _ListFlagsResponse_default_instance_;
class ListProductsResponse;
struct ListProductsResponseDefaultTypeInternal;
extern ListProductsResponseDefaultTypeInternal _ListProductsResponse_default_instance_;
class ListRecommendationsRequest;
struct ListRecommendationsRequestDefaultTypeInternal;
extern ListRecommendationsRequestDefaultTypeInternal _ListRecommendationsRequest_default_instance_;
class ListRecommendationsResponse;
struct ListRecommendationsResponseDefaultTypeInternal;
extern ListRecommendationsResponseDefaultTypeInternal _ListRecommendationsResponse_default_instance_;
class Money;
struct MoneyDefaultTypeInternal;
extern MoneyDefaultTypeInternal _Money_default_instance_;
class OrderItem;
struct OrderItemDefaultTypeInternal;
extern OrderItemDefaultTypeInternal _OrderItem_default_instance_;
class OrderResult;
struct OrderResultDefaultTypeInternal;
extern OrderResultDefaultTypeInternal _OrderResult_default_instance_;
class PlaceOrderRequest;
struct PlaceOrderRequestDefaultTypeInternal;
extern PlaceOrderRequestDefaultTypeInternal _PlaceOrderRequest_default_instance_;
class PlaceOrderResponse;
struct PlaceOrderResponseDefaultTypeInternal;
extern PlaceOrderResponseDefaultTypeInternal _PlaceOrderResponse_default_instance_;
class Product;
struct ProductDefaultTypeInternal;
extern ProductDefaultTypeInternal _Product_default_instance_;
class SearchProductsRequest;
struct SearchProductsRequestDefaultTypeInternal;
extern SearchProductsRequestDefaultTypeInternal _SearchProductsRequest_default_instance_;
class SearchProductsResponse;
struct SearchProductsResponseDefaultTypeInternal;
extern SearchProductsResponseDefaultTypeInternal _SearchProductsResponse_default_instance_;
class SendOrderConfirmationRequest;
struct SendOrderConfirmationRequestDefaultTypeInternal;
extern SendOrderConfirmationRequestDefaultTypeInternal _SendOrderConfirmationRequest_default_instance_;
class ShipOrderRequest;
struct ShipOrderRequestDefaultTypeInternal;
extern ShipOrderRequestDefaultTypeInternal _ShipOrderRequest_default_instance_;
class ShipOrderResponse;
struct ShipOrderResponseDefaultTypeInternal;
extern ShipOrderResponseDefaultTypeInternal _ShipOrderResponse_default_instance_;
class UpdateFlagRequest;
struct UpdateFlagRequestDefaultTypeInternal;
extern UpdateFlagRequestDefaultTypeInternal _UpdateFlagRequest_default_instance_;
class UpdateFlagResponse;
struct UpdateFlagResponseDefaultTypeInternal;
extern UpdateFlagResponseDefaultTypeInternal _UpdateFlagResponse_default_instance_;
}  // namespace oteldemo
PROTOBUF_NAMESPACE_OPEN
template<> ::oteldemo::Ad* Arena::CreateMaybeMessage<::oteldemo::Ad>(Arena*);
template<> ::oteldemo::AdRequest* Arena::CreateMaybeMessage<::oteldemo::AdRequest>(Arena*);
template<> ::oteldemo::AdResponse* Arena::CreateMaybeMessage<::oteldemo::AdResponse>(Arena*);
template<> ::oteldemo::AddItemRequest* Arena::CreateMaybeMessage<::oteldemo::AddItemRequest>(Arena*);
template<> ::oteldemo::Address* Arena::CreateMaybeMessage<::oteldemo::Address>(Arena*);
template<> ::oteldemo::Cart* Arena::CreateMaybeMessage<::oteldemo::Cart>(Arena*);
template<> ::oteldemo::CartItem* Arena::CreateMaybeMessage<::oteldemo::CartItem>(Arena*);
template<> ::oteldemo::ChargeRequest* Arena::CreateMaybeMessage<::oteldemo::ChargeRequest>(Arena*);
template<> ::oteldemo::ChargeResponse* Arena::CreateMaybeMessage<::oteldemo::ChargeResponse>(Arena*);
template<> ::oteldemo::CreateFlagRequest* Arena::CreateMaybeMessage<::oteldemo::CreateFlagRequest>(Arena*);
template<> ::oteldemo::CreateFlagResponse* Arena::CreateMaybeMessage<::oteldemo::CreateFlagResponse>(Arena*);
template<> ::oteldemo::CreditCardInfo* Arena::CreateMaybeMessage<::oteldemo::CreditCardInfo>(Arena*);
template<> ::oteldemo::CurrencyConversionRequest* Arena::CreateMaybeMessage<::oteldemo::CurrencyConversionRequest>(Arena*);
template<> ::oteldemo::DeleteFlagRequest* Arena::CreateMaybeMessage<::oteldemo::DeleteFlagRequest>(Arena*);
template<> ::oteldemo::DeleteFlagResponse* Arena::CreateMaybeMessage<::oteldemo::DeleteFlagResponse>(Arena*);
template<> ::oteldemo::Empty* Arena::CreateMaybeMessage<::oteldemo::Empty>(Arena*);
template<> ::oteldemo::EmptyCartRequest* Arena::CreateMaybeMessage<::oteldemo::EmptyCartRequest>(Arena*);
template<> ::oteldemo::Flag* Arena::CreateMaybeMessage<::oteldemo::Flag>(Arena*);
template<> ::oteldemo::GetCartRequest* Arena::CreateMaybeMessage<::oteldemo::GetCartRequest>(Arena*);
template<> ::oteldemo::GetFlagRequest* Arena::CreateMaybeMessage<::oteldemo::GetFlagRequest>(Arena*);
template<> ::oteldemo::GetFlagResponse* Arena::CreateMaybeMessage<::oteldemo::GetFlagResponse>(Arena*);
template<> ::oteldemo::GetProductRequest* Arena::CreateMaybeMessage<::oteldemo::GetProductRequest>(Arena*);
template<> ::oteldemo::GetQuoteRequest* Arena::CreateMaybeMessage<::oteldemo::GetQuoteRequest>(Arena*);
template<> ::oteldemo::GetQuoteResponse* Arena::CreateMaybeMessage<::oteldemo::GetQuoteResponse>(Arena*);
template<> ::oteldemo::GetSupportedCurrenciesResponse* Arena::CreateMaybeMessage<::oteldemo::GetSupportedCurrenciesResponse>(Arena*);
template<> ::oteldemo::ListFlagsRequest* Arena::CreateMaybeMessage<::oteldemo::ListFlagsRequest>(Arena*);
template<> ::oteldemo::ListFlagsResponse* Arena::CreateMaybeMessage<::oteldemo::ListFlagsResponse>(Arena*);
template<> ::oteldemo::ListProductsResponse* Arena::CreateMaybeMessage<::oteldemo::ListProductsResponse>(Arena*);
template<> ::oteldemo::ListRecommendationsRequest* Arena::CreateMaybeMessage<::oteldemo::ListRecommendationsRequest>(Arena*);
template<> ::oteldemo::ListRecommendationsResponse* Arena::CreateMaybeMessage<::oteldemo::ListRecommendationsResponse>(Arena*);
template<> ::oteldemo::Money* Arena::CreateMaybeMessage<::oteldemo::Money>(Arena*);
template<> ::oteldemo::OrderItem* Arena::CreateMaybeMessage<::oteldemo::OrderItem>(Arena*);
template<> ::oteldemo::OrderResult* Arena::CreateMaybeMessage<::oteldemo::OrderResult>(Arena*);
template<> ::oteldemo::PlaceOrderRequest* Arena::CreateMaybeMessage<::oteldemo::PlaceOrderRequest>(Arena*);
template<> ::oteldemo::PlaceOrderResponse* Arena::CreateMaybeMessage<::oteldemo::PlaceOrderResponse>(Arena*);
template<> ::oteldemo::Product* Arena::CreateMaybeMessage<::oteldemo::Product>(Arena*);
template<> ::oteldemo::SearchProductsRequest* Arena::CreateMaybeMessage<::oteldemo::SearchProductsRequest>(Arena*);
template<> ::oteldemo::SearchProductsResponse* Arena::CreateMaybeMessage<::oteldemo::SearchProductsResponse>(Arena*);
template<> ::oteldemo::SendOrderConfirmationRequest* Arena::CreateMaybeMessage<::oteldemo::SendOrderConfirmationRequest>(Arena*);
template<> ::oteldemo::ShipOrderRequest* Arena::CreateMaybeMessage<::oteldemo::ShipOrderRequest>(Arena*);
template<> ::oteldemo::ShipOrderResponse* Arena::CreateMaybeMessage<::oteldemo::ShipOrderResponse>(Arena*);
template<> ::oteldemo::UpdateFlagRequest* Arena::CreateMaybeMessage<::oteldemo::UpdateFlagRequest>(Arena*);
template<> ::oteldemo::UpdateFlagResponse* Arena::CreateMaybeMessage<::oteldemo::UpdateFlagResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace oteldemo {

// ===================================================================

class CartItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.CartItem) */ {
 public:
  inline CartItem() : CartItem(nullptr) {}
  ~CartItem() override;
  explicit PROTOBUF_CONSTEXPR CartItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CartItem(const CartItem& from);
  CartItem(CartItem&& from) noexcept
    : CartItem() {
    *this = ::std::move(from);
  }

  inline CartItem& operator=(const CartItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline CartItem& operator=(CartItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CartItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const CartItem* internal_default_instance() {
    return reinterpret_cast<const CartItem*>(
               &_CartItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CartItem& a, CartItem& b) {
    a.Swap(&b);
  }
  inline void Swap(CartItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CartItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CartItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CartItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CartItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CartItem& from) {
    CartItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CartItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.CartItem";
  }
  protected:
  explicit CartItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProductIdFieldNumber = 1,
    kQuantityFieldNumber = 2,
  };
  // string product_id = 1;
  void clear_product_id();
  const std::string& product_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_product_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_product_id();
  PROTOBUF_NODISCARD std::string* release_product_id();
  void set_allocated_product_id(std::string* product_id);
  private:
  const std::string& _internal_product_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_product_id(const std::string& value);
  std::string* _internal_mutable_product_id();
  public:

  // int32 quantity = 2;
  void clear_quantity();
  int32_t quantity() const;
  void set_quantity(int32_t value);
  private:
  int32_t _internal_quantity() const;
  void _internal_set_quantity(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:oteldemo.CartItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr product_id_;
    int32_t quantity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class AddItemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.AddItemRequest) */ {
 public:
  inline AddItemRequest() : AddItemRequest(nullptr) {}
  ~AddItemRequest() override;
  explicit PROTOBUF_CONSTEXPR AddItemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddItemRequest(const AddItemRequest& from);
  AddItemRequest(AddItemRequest&& from) noexcept
    : AddItemRequest() {
    *this = ::std::move(from);
  }

  inline AddItemRequest& operator=(const AddItemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddItemRequest& operator=(AddItemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddItemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddItemRequest* internal_default_instance() {
    return reinterpret_cast<const AddItemRequest*>(
               &_AddItemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AddItemRequest& a, AddItemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddItemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddItemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddItemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddItemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddItemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddItemRequest& from) {
    AddItemRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddItemRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.AddItemRequest";
  }
  protected:
  explicit AddItemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kItemFieldNumber = 2,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // .oteldemo.CartItem item = 2;
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::oteldemo::CartItem& item() const;
  PROTOBUF_NODISCARD ::oteldemo::CartItem* release_item();
  ::oteldemo::CartItem* mutable_item();
  void set_allocated_item(::oteldemo::CartItem* item);
  private:
  const ::oteldemo::CartItem& _internal_item() const;
  ::oteldemo::CartItem* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::oteldemo::CartItem* item);
  ::oteldemo::CartItem* unsafe_arena_release_item();

  // @@protoc_insertion_point(class_scope:oteldemo.AddItemRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::oteldemo::CartItem* item_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class EmptyCartRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.EmptyCartRequest) */ {
 public:
  inline EmptyCartRequest() : EmptyCartRequest(nullptr) {}
  ~EmptyCartRequest() override;
  explicit PROTOBUF_CONSTEXPR EmptyCartRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EmptyCartRequest(const EmptyCartRequest& from);
  EmptyCartRequest(EmptyCartRequest&& from) noexcept
    : EmptyCartRequest() {
    *this = ::std::move(from);
  }

  inline EmptyCartRequest& operator=(const EmptyCartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmptyCartRequest& operator=(EmptyCartRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmptyCartRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmptyCartRequest* internal_default_instance() {
    return reinterpret_cast<const EmptyCartRequest*>(
               &_EmptyCartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(EmptyCartRequest& a, EmptyCartRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EmptyCartRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmptyCartRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmptyCartRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmptyCartRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EmptyCartRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EmptyCartRequest& from) {
    EmptyCartRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmptyCartRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.EmptyCartRequest";
  }
  protected:
  explicit EmptyCartRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // @@protoc_insertion_point(class_scope:oteldemo.EmptyCartRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class GetCartRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.GetCartRequest) */ {
 public:
  inline GetCartRequest() : GetCartRequest(nullptr) {}
  ~GetCartRequest() override;
  explicit PROTOBUF_CONSTEXPR GetCartRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetCartRequest(const GetCartRequest& from);
  GetCartRequest(GetCartRequest&& from) noexcept
    : GetCartRequest() {
    *this = ::std::move(from);
  }

  inline GetCartRequest& operator=(const GetCartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCartRequest& operator=(GetCartRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCartRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCartRequest* internal_default_instance() {
    return reinterpret_cast<const GetCartRequest*>(
               &_GetCartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetCartRequest& a, GetCartRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetCartRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCartRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCartRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetCartRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetCartRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetCartRequest& from) {
    GetCartRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetCartRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.GetCartRequest";
  }
  protected:
  explicit GetCartRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // @@protoc_insertion_point(class_scope:oteldemo.GetCartRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class Cart final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.Cart) */ {
 public:
  inline Cart() : Cart(nullptr) {}
  ~Cart() override;
  explicit PROTOBUF_CONSTEXPR Cart(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Cart(const Cart& from);
  Cart(Cart&& from) noexcept
    : Cart() {
    *this = ::std::move(from);
  }

  inline Cart& operator=(const Cart& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cart& operator=(Cart&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Cart& default_instance() {
    return *internal_default_instance();
  }
  static inline const Cart* internal_default_instance() {
    return reinterpret_cast<const Cart*>(
               &_Cart_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Cart& a, Cart& b) {
    a.Swap(&b);
  }
  inline void Swap(Cart* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Cart* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Cart* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Cart>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Cart& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Cart& from) {
    Cart::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Cart* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.Cart";
  }
  protected:
  explicit Cart(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kUserIdFieldNumber = 1,
  };
  // repeated .oteldemo.CartItem items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::oteldemo::CartItem* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::CartItem >*
      mutable_items();
  private:
  const ::oteldemo::CartItem& _internal_items(int index) const;
  ::oteldemo::CartItem* _internal_add_items();
  public:
  const ::oteldemo::CartItem& items(int index) const;
  ::oteldemo::CartItem* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::CartItem >&
      items() const;

  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // @@protoc_insertion_point(class_scope:oteldemo.Cart)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::CartItem > items_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class Empty final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:oteldemo.Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Empty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Empty(const Empty& from);
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Empty& default_instance() {
    return *internal_default_instance();
  }
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }
  inline void Swap(Empty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Empty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.Empty";
  }
  protected:
  explicit Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:oteldemo.Empty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class ListRecommendationsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.ListRecommendationsRequest) */ {
 public:
  inline ListRecommendationsRequest() : ListRecommendationsRequest(nullptr) {}
  ~ListRecommendationsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListRecommendationsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListRecommendationsRequest(const ListRecommendationsRequest& from);
  ListRecommendationsRequest(ListRecommendationsRequest&& from) noexcept
    : ListRecommendationsRequest() {
    *this = ::std::move(from);
  }

  inline ListRecommendationsRequest& operator=(const ListRecommendationsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRecommendationsRequest& operator=(ListRecommendationsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRecommendationsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRecommendationsRequest* internal_default_instance() {
    return reinterpret_cast<const ListRecommendationsRequest*>(
               &_ListRecommendationsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ListRecommendationsRequest& a, ListRecommendationsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRecommendationsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRecommendationsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListRecommendationsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListRecommendationsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListRecommendationsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListRecommendationsRequest& from) {
    ListRecommendationsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRecommendationsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.ListRecommendationsRequest";
  }
  protected:
  explicit ListRecommendationsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProductIdsFieldNumber = 2,
    kUserIdFieldNumber = 1,
  };
  // repeated string product_ids = 2;
  int product_ids_size() const;
  private:
  int _internal_product_ids_size() const;
  public:
  void clear_product_ids();
  const std::string& product_ids(int index) const;
  std::string* mutable_product_ids(int index);
  void set_product_ids(int index, const std::string& value);
  void set_product_ids(int index, std::string&& value);
  void set_product_ids(int index, const char* value);
  void set_product_ids(int index, const char* value, size_t size);
  std::string* add_product_ids();
  void add_product_ids(const std::string& value);
  void add_product_ids(std::string&& value);
  void add_product_ids(const char* value);
  void add_product_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& product_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_product_ids();
  private:
  const std::string& _internal_product_ids(int index) const;
  std::string* _internal_add_product_ids();
  public:

  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // @@protoc_insertion_point(class_scope:oteldemo.ListRecommendationsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> product_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class ListRecommendationsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.ListRecommendationsResponse) */ {
 public:
  inline ListRecommendationsResponse() : ListRecommendationsResponse(nullptr) {}
  ~ListRecommendationsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListRecommendationsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListRecommendationsResponse(const ListRecommendationsResponse& from);
  ListRecommendationsResponse(ListRecommendationsResponse&& from) noexcept
    : ListRecommendationsResponse() {
    *this = ::std::move(from);
  }

  inline ListRecommendationsResponse& operator=(const ListRecommendationsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRecommendationsResponse& operator=(ListRecommendationsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRecommendationsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRecommendationsResponse* internal_default_instance() {
    return reinterpret_cast<const ListRecommendationsResponse*>(
               &_ListRecommendationsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ListRecommendationsResponse& a, ListRecommendationsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRecommendationsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRecommendationsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListRecommendationsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListRecommendationsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListRecommendationsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListRecommendationsResponse& from) {
    ListRecommendationsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRecommendationsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.ListRecommendationsResponse";
  }
  protected:
  explicit ListRecommendationsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProductIdsFieldNumber = 1,
  };
  // repeated string product_ids = 1;
  int product_ids_size() const;
  private:
  int _internal_product_ids_size() const;
  public:
  void clear_product_ids();
  const std::string& product_ids(int index) const;
  std::string* mutable_product_ids(int index);
  void set_product_ids(int index, const std::string& value);
  void set_product_ids(int index, std::string&& value);
  void set_product_ids(int index, const char* value);
  void set_product_ids(int index, const char* value, size_t size);
  std::string* add_product_ids();
  void add_product_ids(const std::string& value);
  void add_product_ids(std::string&& value);
  void add_product_ids(const char* value);
  void add_product_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& product_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_product_ids();
  private:
  const std::string& _internal_product_ids(int index) const;
  std::string* _internal_add_product_ids();
  public:

  // @@protoc_insertion_point(class_scope:oteldemo.ListRecommendationsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> product_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class Product final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.Product) */ {
 public:
  inline Product() : Product(nullptr) {}
  ~Product() override;
  explicit PROTOBUF_CONSTEXPR Product(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Product(const Product& from);
  Product(Product&& from) noexcept
    : Product() {
    *this = ::std::move(from);
  }

  inline Product& operator=(const Product& from) {
    CopyFrom(from);
    return *this;
  }
  inline Product& operator=(Product&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Product& default_instance() {
    return *internal_default_instance();
  }
  static inline const Product* internal_default_instance() {
    return reinterpret_cast<const Product*>(
               &_Product_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Product& a, Product& b) {
    a.Swap(&b);
  }
  inline void Swap(Product* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Product* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Product* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Product>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Product& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Product& from) {
    Product::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Product* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.Product";
  }
  protected:
  explicit Product(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoriesFieldNumber = 6,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kPictureFieldNumber = 4,
    kPriceUsdFieldNumber = 5,
  };
  // repeated string categories = 6;
  int categories_size() const;
  private:
  int _internal_categories_size() const;
  public:
  void clear_categories();
  const std::string& categories(int index) const;
  std::string* mutable_categories(int index);
  void set_categories(int index, const std::string& value);
  void set_categories(int index, std::string&& value);
  void set_categories(int index, const char* value);
  void set_categories(int index, const char* value, size_t size);
  std::string* add_categories();
  void add_categories(const std::string& value);
  void add_categories(std::string&& value);
  void add_categories(const char* value);
  void add_categories(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& categories() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_categories();
  private:
  const std::string& _internal_categories(int index) const;
  std::string* _internal_add_categories();
  public:

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string picture = 4;
  void clear_picture();
  const std::string& picture() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_picture(ArgT0&& arg0, ArgT... args);
  std::string* mutable_picture();
  PROTOBUF_NODISCARD std::string* release_picture();
  void set_allocated_picture(std::string* picture);
  private:
  const std::string& _internal_picture() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_picture(const std::string& value);
  std::string* _internal_mutable_picture();
  public:

  // .oteldemo.Money price_usd = 5;
  bool has_price_usd() const;
  private:
  bool _internal_has_price_usd() const;
  public:
  void clear_price_usd();
  const ::oteldemo::Money& price_usd() const;
  PROTOBUF_NODISCARD ::oteldemo::Money* release_price_usd();
  ::oteldemo::Money* mutable_price_usd();
  void set_allocated_price_usd(::oteldemo::Money* price_usd);
  private:
  const ::oteldemo::Money& _internal_price_usd() const;
  ::oteldemo::Money* _internal_mutable_price_usd();
  public:
  void unsafe_arena_set_allocated_price_usd(
      ::oteldemo::Money* price_usd);
  ::oteldemo::Money* unsafe_arena_release_price_usd();

  // @@protoc_insertion_point(class_scope:oteldemo.Product)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> categories_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr picture_;
    ::oteldemo::Money* price_usd_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class ListProductsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.ListProductsResponse) */ {
 public:
  inline ListProductsResponse() : ListProductsResponse(nullptr) {}
  ~ListProductsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListProductsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListProductsResponse(const ListProductsResponse& from);
  ListProductsResponse(ListProductsResponse&& from) noexcept
    : ListProductsResponse() {
    *this = ::std::move(from);
  }

  inline ListProductsResponse& operator=(const ListProductsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListProductsResponse& operator=(ListProductsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListProductsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListProductsResponse* internal_default_instance() {
    return reinterpret_cast<const ListProductsResponse*>(
               &_ListProductsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ListProductsResponse& a, ListProductsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListProductsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListProductsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListProductsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListProductsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListProductsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListProductsResponse& from) {
    ListProductsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListProductsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.ListProductsResponse";
  }
  protected:
  explicit ListProductsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProductsFieldNumber = 1,
  };
  // repeated .oteldemo.Product products = 1;
  int products_size() const;
  private:
  int _internal_products_size() const;
  public:
  void clear_products();
  ::oteldemo::Product* mutable_products(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::Product >*
      mutable_products();
  private:
  const ::oteldemo::Product& _internal_products(int index) const;
  ::oteldemo::Product* _internal_add_products();
  public:
  const ::oteldemo::Product& products(int index) const;
  ::oteldemo::Product* add_products();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::Product >&
      products() const;

  // @@protoc_insertion_point(class_scope:oteldemo.ListProductsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::Product > products_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class GetProductRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.GetProductRequest) */ {
 public:
  inline GetProductRequest() : GetProductRequest(nullptr) {}
  ~GetProductRequest() override;
  explicit PROTOBUF_CONSTEXPR GetProductRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetProductRequest(const GetProductRequest& from);
  GetProductRequest(GetProductRequest&& from) noexcept
    : GetProductRequest() {
    *this = ::std::move(from);
  }

  inline GetProductRequest& operator=(const GetProductRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProductRequest& operator=(GetProductRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetProductRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetProductRequest* internal_default_instance() {
    return reinterpret_cast<const GetProductRequest*>(
               &_GetProductRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetProductRequest& a, GetProductRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProductRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProductRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetProductRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetProductRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetProductRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetProductRequest& from) {
    GetProductRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetProductRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.GetProductRequest";
  }
  protected:
  explicit GetProductRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:oteldemo.GetProductRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class SearchProductsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.SearchProductsRequest) */ {
 public:
  inline SearchProductsRequest() : SearchProductsRequest(nullptr) {}
  ~SearchProductsRequest() override;
  explicit PROTOBUF_CONSTEXPR SearchProductsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchProductsRequest(const SearchProductsRequest& from);
  SearchProductsRequest(SearchProductsRequest&& from) noexcept
    : SearchProductsRequest() {
    *this = ::std::move(from);
  }

  inline SearchProductsRequest& operator=(const SearchProductsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchProductsRequest& operator=(SearchProductsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchProductsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchProductsRequest* internal_default_instance() {
    return reinterpret_cast<const SearchProductsRequest*>(
               &_SearchProductsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SearchProductsRequest& a, SearchProductsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchProductsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchProductsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchProductsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchProductsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchProductsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SearchProductsRequest& from) {
    SearchProductsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchProductsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.SearchProductsRequest";
  }
  protected:
  explicit SearchProductsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQueryFieldNumber = 1,
  };
  // string query = 1;
  void clear_query();
  const std::string& query() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_query(ArgT0&& arg0, ArgT... args);
  std::string* mutable_query();
  PROTOBUF_NODISCARD std::string* release_query();
  void set_allocated_query(std::string* query);
  private:
  const std::string& _internal_query() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_query(const std::string& value);
  std::string* _internal_mutable_query();
  public:

  // @@protoc_insertion_point(class_scope:oteldemo.SearchProductsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr query_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class SearchProductsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.SearchProductsResponse) */ {
 public:
  inline SearchProductsResponse() : SearchProductsResponse(nullptr) {}
  ~SearchProductsResponse() override;
  explicit PROTOBUF_CONSTEXPR SearchProductsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchProductsResponse(const SearchProductsResponse& from);
  SearchProductsResponse(SearchProductsResponse&& from) noexcept
    : SearchProductsResponse() {
    *this = ::std::move(from);
  }

  inline SearchProductsResponse& operator=(const SearchProductsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchProductsResponse& operator=(SearchProductsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchProductsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchProductsResponse* internal_default_instance() {
    return reinterpret_cast<const SearchProductsResponse*>(
               &_SearchProductsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SearchProductsResponse& a, SearchProductsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchProductsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchProductsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchProductsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchProductsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchProductsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SearchProductsResponse& from) {
    SearchProductsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchProductsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.SearchProductsResponse";
  }
  protected:
  explicit SearchProductsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 1,
  };
  // repeated .oteldemo.Product results = 1;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::oteldemo::Product* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::Product >*
      mutable_results();
  private:
  const ::oteldemo::Product& _internal_results(int index) const;
  ::oteldemo::Product* _internal_add_results();
  public:
  const ::oteldemo::Product& results(int index) const;
  ::oteldemo::Product* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::Product >&
      results() const;

  // @@protoc_insertion_point(class_scope:oteldemo.SearchProductsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::Product > results_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class GetQuoteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.GetQuoteRequest) */ {
 public:
  inline GetQuoteRequest() : GetQuoteRequest(nullptr) {}
  ~GetQuoteRequest() override;
  explicit PROTOBUF_CONSTEXPR GetQuoteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetQuoteRequest(const GetQuoteRequest& from);
  GetQuoteRequest(GetQuoteRequest&& from) noexcept
    : GetQuoteRequest() {
    *this = ::std::move(from);
  }

  inline GetQuoteRequest& operator=(const GetQuoteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetQuoteRequest& operator=(GetQuoteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetQuoteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetQuoteRequest* internal_default_instance() {
    return reinterpret_cast<const GetQuoteRequest*>(
               &_GetQuoteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetQuoteRequest& a, GetQuoteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetQuoteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetQuoteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetQuoteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetQuoteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetQuoteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetQuoteRequest& from) {
    GetQuoteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetQuoteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.GetQuoteRequest";
  }
  protected:
  explicit GetQuoteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kAddressFieldNumber = 1,
  };
  // repeated .oteldemo.CartItem items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::oteldemo::CartItem* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::CartItem >*
      mutable_items();
  private:
  const ::oteldemo::CartItem& _internal_items(int index) const;
  ::oteldemo::CartItem* _internal_add_items();
  public:
  const ::oteldemo::CartItem& items(int index) const;
  ::oteldemo::CartItem* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::CartItem >&
      items() const;

  // .oteldemo.Address address = 1;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const ::oteldemo::Address& address() const;
  PROTOBUF_NODISCARD ::oteldemo::Address* release_address();
  ::oteldemo::Address* mutable_address();
  void set_allocated_address(::oteldemo::Address* address);
  private:
  const ::oteldemo::Address& _internal_address() const;
  ::oteldemo::Address* _internal_mutable_address();
  public:
  void unsafe_arena_set_allocated_address(
      ::oteldemo::Address* address);
  ::oteldemo::Address* unsafe_arena_release_address();

  // @@protoc_insertion_point(class_scope:oteldemo.GetQuoteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::CartItem > items_;
    ::oteldemo::Address* address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class GetQuoteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.GetQuoteResponse) */ {
 public:
  inline GetQuoteResponse() : GetQuoteResponse(nullptr) {}
  ~GetQuoteResponse() override;
  explicit PROTOBUF_CONSTEXPR GetQuoteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetQuoteResponse(const GetQuoteResponse& from);
  GetQuoteResponse(GetQuoteResponse&& from) noexcept
    : GetQuoteResponse() {
    *this = ::std::move(from);
  }

  inline GetQuoteResponse& operator=(const GetQuoteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetQuoteResponse& operator=(GetQuoteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetQuoteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetQuoteResponse* internal_default_instance() {
    return reinterpret_cast<const GetQuoteResponse*>(
               &_GetQuoteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetQuoteResponse& a, GetQuoteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetQuoteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetQuoteResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetQuoteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetQuoteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetQuoteResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetQuoteResponse& from) {
    GetQuoteResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetQuoteResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.GetQuoteResponse";
  }
  protected:
  explicit GetQuoteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCostUsdFieldNumber = 1,
  };
  // .oteldemo.Money cost_usd = 1;
  bool has_cost_usd() const;
  private:
  bool _internal_has_cost_usd() const;
  public:
  void clear_cost_usd();
  const ::oteldemo::Money& cost_usd() const;
  PROTOBUF_NODISCARD ::oteldemo::Money* release_cost_usd();
  ::oteldemo::Money* mutable_cost_usd();
  void set_allocated_cost_usd(::oteldemo::Money* cost_usd);
  private:
  const ::oteldemo::Money& _internal_cost_usd() const;
  ::oteldemo::Money* _internal_mutable_cost_usd();
  public:
  void unsafe_arena_set_allocated_cost_usd(
      ::oteldemo::Money* cost_usd);
  ::oteldemo::Money* unsafe_arena_release_cost_usd();

  // @@protoc_insertion_point(class_scope:oteldemo.GetQuoteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::oteldemo::Money* cost_usd_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class ShipOrderRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.ShipOrderRequest) */ {
 public:
  inline ShipOrderRequest() : ShipOrderRequest(nullptr) {}
  ~ShipOrderRequest() override;
  explicit PROTOBUF_CONSTEXPR ShipOrderRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShipOrderRequest(const ShipOrderRequest& from);
  ShipOrderRequest(ShipOrderRequest&& from) noexcept
    : ShipOrderRequest() {
    *this = ::std::move(from);
  }

  inline ShipOrderRequest& operator=(const ShipOrderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShipOrderRequest& operator=(ShipOrderRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShipOrderRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShipOrderRequest* internal_default_instance() {
    return reinterpret_cast<const ShipOrderRequest*>(
               &_ShipOrderRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ShipOrderRequest& a, ShipOrderRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ShipOrderRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShipOrderRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShipOrderRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShipOrderRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShipOrderRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShipOrderRequest& from) {
    ShipOrderRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShipOrderRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.ShipOrderRequest";
  }
  protected:
  explicit ShipOrderRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kAddressFieldNumber = 1,
  };
  // repeated .oteldemo.CartItem items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::oteldemo::CartItem* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::CartItem >*
      mutable_items();
  private:
  const ::oteldemo::CartItem& _internal_items(int index) const;
  ::oteldemo::CartItem* _internal_add_items();
  public:
  const ::oteldemo::CartItem& items(int index) const;
  ::oteldemo::CartItem* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::CartItem >&
      items() const;

  // .oteldemo.Address address = 1;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const ::oteldemo::Address& address() const;
  PROTOBUF_NODISCARD ::oteldemo::Address* release_address();
  ::oteldemo::Address* mutable_address();
  void set_allocated_address(::oteldemo::Address* address);
  private:
  const ::oteldemo::Address& _internal_address() const;
  ::oteldemo::Address* _internal_mutable_address();
  public:
  void unsafe_arena_set_allocated_address(
      ::oteldemo::Address* address);
  ::oteldemo::Address* unsafe_arena_release_address();

  // @@protoc_insertion_point(class_scope:oteldemo.ShipOrderRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::CartItem > items_;
    ::oteldemo::Address* address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class ShipOrderResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.ShipOrderResponse) */ {
 public:
  inline ShipOrderResponse() : ShipOrderResponse(nullptr) {}
  ~ShipOrderResponse() override;
  explicit PROTOBUF_CONSTEXPR ShipOrderResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShipOrderResponse(const ShipOrderResponse& from);
  ShipOrderResponse(ShipOrderResponse&& from) noexcept
    : ShipOrderResponse() {
    *this = ::std::move(from);
  }

  inline ShipOrderResponse& operator=(const ShipOrderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShipOrderResponse& operator=(ShipOrderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShipOrderResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShipOrderResponse* internal_default_instance() {
    return reinterpret_cast<const ShipOrderResponse*>(
               &_ShipOrderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ShipOrderResponse& a, ShipOrderResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ShipOrderResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShipOrderResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShipOrderResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShipOrderResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShipOrderResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShipOrderResponse& from) {
    ShipOrderResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShipOrderResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.ShipOrderResponse";
  }
  protected:
  explicit ShipOrderResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackingIdFieldNumber = 1,
  };
  // string tracking_id = 1;
  void clear_tracking_id();
  const std::string& tracking_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tracking_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tracking_id();
  PROTOBUF_NODISCARD std::string* release_tracking_id();
  void set_allocated_tracking_id(std::string* tracking_id);
  private:
  const std::string& _internal_tracking_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tracking_id(const std::string& value);
  std::string* _internal_mutable_tracking_id();
  public:

  // @@protoc_insertion_point(class_scope:oteldemo.ShipOrderResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tracking_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class Address final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.Address) */ {
 public:
  inline Address() : Address(nullptr) {}
  ~Address() override;
  explicit PROTOBUF_CONSTEXPR Address(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Address(const Address& from);
  Address(Address&& from) noexcept
    : Address() {
    *this = ::std::move(from);
  }

  inline Address& operator=(const Address& from) {
    CopyFrom(from);
    return *this;
  }
  inline Address& operator=(Address&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Address& default_instance() {
    return *internal_default_instance();
  }
  static inline const Address* internal_default_instance() {
    return reinterpret_cast<const Address*>(
               &_Address_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Address& a, Address& b) {
    a.Swap(&b);
  }
  inline void Swap(Address* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Address* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Address* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Address>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Address& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Address& from) {
    Address::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Address* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.Address";
  }
  protected:
  explicit Address(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreetAddressFieldNumber = 1,
    kCityFieldNumber = 2,
    kStateFieldNumber = 3,
    kCountryFieldNumber = 4,
    kZipCodeFieldNumber = 5,
  };
  // string street_address = 1;
  void clear_street_address();
  const std::string& street_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_street_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_street_address();
  PROTOBUF_NODISCARD std::string* release_street_address();
  void set_allocated_street_address(std::string* street_address);
  private:
  const std::string& _internal_street_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_street_address(const std::string& value);
  std::string* _internal_mutable_street_address();
  public:

  // string city = 2;
  void clear_city();
  const std::string& city() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_city(ArgT0&& arg0, ArgT... args);
  std::string* mutable_city();
  PROTOBUF_NODISCARD std::string* release_city();
  void set_allocated_city(std::string* city);
  private:
  const std::string& _internal_city() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_city(const std::string& value);
  std::string* _internal_mutable_city();
  public:

  // string state = 3;
  void clear_state();
  const std::string& state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* state);
  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(const std::string& value);
  std::string* _internal_mutable_state();
  public:

  // string country = 4;
  void clear_country();
  const std::string& country() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_country(ArgT0&& arg0, ArgT... args);
  std::string* mutable_country();
  PROTOBUF_NODISCARD std::string* release_country();
  void set_allocated_country(std::string* country);
  private:
  const std::string& _internal_country() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_country(const std::string& value);
  std::string* _internal_mutable_country();
  public:

  // string zip_code = 5;
  void clear_zip_code();
  const std::string& zip_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_zip_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_zip_code();
  PROTOBUF_NODISCARD std::string* release_zip_code();
  void set_allocated_zip_code(std::string* zip_code);
  private:
  const std::string& _internal_zip_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_zip_code(const std::string& value);
  std::string* _internal_mutable_zip_code();
  public:

  // @@protoc_insertion_point(class_scope:oteldemo.Address)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr street_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr city_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr country_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr zip_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class Money final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.Money) */ {
 public:
  inline Money() : Money(nullptr) {}
  ~Money() override;
  explicit PROTOBUF_CONSTEXPR Money(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Money(const Money& from);
  Money(Money&& from) noexcept
    : Money() {
    *this = ::std::move(from);
  }

  inline Money& operator=(const Money& from) {
    CopyFrom(from);
    return *this;
  }
  inline Money& operator=(Money&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Money& default_instance() {
    return *internal_default_instance();
  }
  static inline const Money* internal_default_instance() {
    return reinterpret_cast<const Money*>(
               &_Money_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Money& a, Money& b) {
    a.Swap(&b);
  }
  inline void Swap(Money* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Money* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Money* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Money>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Money& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Money& from) {
    Money::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Money* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.Money";
  }
  protected:
  explicit Money(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrencyCodeFieldNumber = 1,
    kUnitsFieldNumber = 2,
    kNanosFieldNumber = 3,
  };
  // string currency_code = 1;
  void clear_currency_code();
  const std::string& currency_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_currency_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_currency_code();
  PROTOBUF_NODISCARD std::string* release_currency_code();
  void set_allocated_currency_code(std::string* currency_code);
  private:
  const std::string& _internal_currency_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_currency_code(const std::string& value);
  std::string* _internal_mutable_currency_code();
  public:

  // int64 units = 2;
  void clear_units();
  int64_t units() const;
  void set_units(int64_t value);
  private:
  int64_t _internal_units() const;
  void _internal_set_units(int64_t value);
  public:

  // int32 nanos = 3;
  void clear_nanos();
  int32_t nanos() const;
  void set_nanos(int32_t value);
  private:
  int32_t _internal_nanos() const;
  void _internal_set_nanos(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:oteldemo.Money)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr currency_code_;
    int64_t units_;
    int32_t nanos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class GetSupportedCurrenciesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.GetSupportedCurrenciesResponse) */ {
 public:
  inline GetSupportedCurrenciesResponse() : GetSupportedCurrenciesResponse(nullptr) {}
  ~GetSupportedCurrenciesResponse() override;
  explicit PROTOBUF_CONSTEXPR GetSupportedCurrenciesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSupportedCurrenciesResponse(const GetSupportedCurrenciesResponse& from);
  GetSupportedCurrenciesResponse(GetSupportedCurrenciesResponse&& from) noexcept
    : GetSupportedCurrenciesResponse() {
    *this = ::std::move(from);
  }

  inline GetSupportedCurrenciesResponse& operator=(const GetSupportedCurrenciesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSupportedCurrenciesResponse& operator=(GetSupportedCurrenciesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSupportedCurrenciesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSupportedCurrenciesResponse* internal_default_instance() {
    return reinterpret_cast<const GetSupportedCurrenciesResponse*>(
               &_GetSupportedCurrenciesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(GetSupportedCurrenciesResponse& a, GetSupportedCurrenciesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSupportedCurrenciesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSupportedCurrenciesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSupportedCurrenciesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSupportedCurrenciesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSupportedCurrenciesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSupportedCurrenciesResponse& from) {
    GetSupportedCurrenciesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSupportedCurrenciesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.GetSupportedCurrenciesResponse";
  }
  protected:
  explicit GetSupportedCurrenciesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrencyCodesFieldNumber = 1,
  };
  // repeated string currency_codes = 1;
  int currency_codes_size() const;
  private:
  int _internal_currency_codes_size() const;
  public:
  void clear_currency_codes();
  const std::string& currency_codes(int index) const;
  std::string* mutable_currency_codes(int index);
  void set_currency_codes(int index, const std::string& value);
  void set_currency_codes(int index, std::string&& value);
  void set_currency_codes(int index, const char* value);
  void set_currency_codes(int index, const char* value, size_t size);
  std::string* add_currency_codes();
  void add_currency_codes(const std::string& value);
  void add_currency_codes(std::string&& value);
  void add_currency_codes(const char* value);
  void add_currency_codes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& currency_codes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_currency_codes();
  private:
  const std::string& _internal_currency_codes(int index) const;
  std::string* _internal_add_currency_codes();
  public:

  // @@protoc_insertion_point(class_scope:oteldemo.GetSupportedCurrenciesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> currency_codes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class CurrencyConversionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.CurrencyConversionRequest) */ {
 public:
  inline CurrencyConversionRequest() : CurrencyConversionRequest(nullptr) {}
  ~CurrencyConversionRequest() override;
  explicit PROTOBUF_CONSTEXPR CurrencyConversionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CurrencyConversionRequest(const CurrencyConversionRequest& from);
  CurrencyConversionRequest(CurrencyConversionRequest&& from) noexcept
    : CurrencyConversionRequest() {
    *this = ::std::move(from);
  }

  inline CurrencyConversionRequest& operator=(const CurrencyConversionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CurrencyConversionRequest& operator=(CurrencyConversionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CurrencyConversionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CurrencyConversionRequest* internal_default_instance() {
    return reinterpret_cast<const CurrencyConversionRequest*>(
               &_CurrencyConversionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CurrencyConversionRequest& a, CurrencyConversionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CurrencyConversionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CurrencyConversionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CurrencyConversionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CurrencyConversionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CurrencyConversionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CurrencyConversionRequest& from) {
    CurrencyConversionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CurrencyConversionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.CurrencyConversionRequest";
  }
  protected:
  explicit CurrencyConversionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToCodeFieldNumber = 2,
    kFromFieldNumber = 1,
  };
  // string to_code = 2;
  void clear_to_code();
  const std::string& to_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_code();
  PROTOBUF_NODISCARD std::string* release_to_code();
  void set_allocated_to_code(std::string* to_code);
  private:
  const std::string& _internal_to_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_code(const std::string& value);
  std::string* _internal_mutable_to_code();
  public:

  // .oteldemo.Money from = 1;
  bool has_from() const;
  private:
  bool _internal_has_from() const;
  public:
  void clear_from();
  const ::oteldemo::Money& from() const;
  PROTOBUF_NODISCARD ::oteldemo::Money* release_from();
  ::oteldemo::Money* mutable_from();
  void set_allocated_from(::oteldemo::Money* from);
  private:
  const ::oteldemo::Money& _internal_from() const;
  ::oteldemo::Money* _internal_mutable_from();
  public:
  void unsafe_arena_set_allocated_from(
      ::oteldemo::Money* from);
  ::oteldemo::Money* unsafe_arena_release_from();

  // @@protoc_insertion_point(class_scope:oteldemo.CurrencyConversionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_code_;
    ::oteldemo::Money* from_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class CreditCardInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.CreditCardInfo) */ {
 public:
  inline CreditCardInfo() : CreditCardInfo(nullptr) {}
  ~CreditCardInfo() override;
  explicit PROTOBUF_CONSTEXPR CreditCardInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreditCardInfo(const CreditCardInfo& from);
  CreditCardInfo(CreditCardInfo&& from) noexcept
    : CreditCardInfo() {
    *this = ::std::move(from);
  }

  inline CreditCardInfo& operator=(const CreditCardInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreditCardInfo& operator=(CreditCardInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreditCardInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreditCardInfo* internal_default_instance() {
    return reinterpret_cast<const CreditCardInfo*>(
               &_CreditCardInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(CreditCardInfo& a, CreditCardInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CreditCardInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreditCardInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreditCardInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreditCardInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreditCardInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreditCardInfo& from) {
    CreditCardInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreditCardInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.CreditCardInfo";
  }
  protected:
  explicit CreditCardInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreditCardNumberFieldNumber = 1,
    kCreditCardCvvFieldNumber = 2,
    kCreditCardExpirationYearFieldNumber = 3,
    kCreditCardExpirationMonthFieldNumber = 4,
  };
  // string credit_card_number = 1;
  void clear_credit_card_number();
  const std::string& credit_card_number() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_credit_card_number(ArgT0&& arg0, ArgT... args);
  std::string* mutable_credit_card_number();
  PROTOBUF_NODISCARD std::string* release_credit_card_number();
  void set_allocated_credit_card_number(std::string* credit_card_number);
  private:
  const std::string& _internal_credit_card_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_credit_card_number(const std::string& value);
  std::string* _internal_mutable_credit_card_number();
  public:

  // int32 credit_card_cvv = 2;
  void clear_credit_card_cvv();
  int32_t credit_card_cvv() const;
  void set_credit_card_cvv(int32_t value);
  private:
  int32_t _internal_credit_card_cvv() const;
  void _internal_set_credit_card_cvv(int32_t value);
  public:

  // int32 credit_card_expiration_year = 3;
  void clear_credit_card_expiration_year();
  int32_t credit_card_expiration_year() const;
  void set_credit_card_expiration_year(int32_t value);
  private:
  int32_t _internal_credit_card_expiration_year() const;
  void _internal_set_credit_card_expiration_year(int32_t value);
  public:

  // int32 credit_card_expiration_month = 4;
  void clear_credit_card_expiration_month();
  int32_t credit_card_expiration_month() const;
  void set_credit_card_expiration_month(int32_t value);
  private:
  int32_t _internal_credit_card_expiration_month() const;
  void _internal_set_credit_card_expiration_month(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:oteldemo.CreditCardInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr credit_card_number_;
    int32_t credit_card_cvv_;
    int32_t credit_card_expiration_year_;
    int32_t credit_card_expiration_month_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class ChargeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.ChargeRequest) */ {
 public:
  inline ChargeRequest() : ChargeRequest(nullptr) {}
  ~ChargeRequest() override;
  explicit PROTOBUF_CONSTEXPR ChargeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChargeRequest(const ChargeRequest& from);
  ChargeRequest(ChargeRequest&& from) noexcept
    : ChargeRequest() {
    *this = ::std::move(from);
  }

  inline ChargeRequest& operator=(const ChargeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChargeRequest& operator=(ChargeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChargeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChargeRequest* internal_default_instance() {
    return reinterpret_cast<const ChargeRequest*>(
               &_ChargeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ChargeRequest& a, ChargeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ChargeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChargeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChargeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChargeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChargeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChargeRequest& from) {
    ChargeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChargeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.ChargeRequest";
  }
  protected:
  explicit ChargeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAmountFieldNumber = 1,
    kCreditCardFieldNumber = 2,
  };
  // .oteldemo.Money amount = 1;
  bool has_amount() const;
  private:
  bool _internal_has_amount() const;
  public:
  void clear_amount();
  const ::oteldemo::Money& amount() const;
  PROTOBUF_NODISCARD ::oteldemo::Money* release_amount();
  ::oteldemo::Money* mutable_amount();
  void set_allocated_amount(::oteldemo::Money* amount);
  private:
  const ::oteldemo::Money& _internal_amount() const;
  ::oteldemo::Money* _internal_mutable_amount();
  public:
  void unsafe_arena_set_allocated_amount(
      ::oteldemo::Money* amount);
  ::oteldemo::Money* unsafe_arena_release_amount();

  // .oteldemo.CreditCardInfo credit_card = 2;
  bool has_credit_card() const;
  private:
  bool _internal_has_credit_card() const;
  public:
  void clear_credit_card();
  const ::oteldemo::CreditCardInfo& credit_card() const;
  PROTOBUF_NODISCARD ::oteldemo::CreditCardInfo* release_credit_card();
  ::oteldemo::CreditCardInfo* mutable_credit_card();
  void set_allocated_credit_card(::oteldemo::CreditCardInfo* credit_card);
  private:
  const ::oteldemo::CreditCardInfo& _internal_credit_card() const;
  ::oteldemo::CreditCardInfo* _internal_mutable_credit_card();
  public:
  void unsafe_arena_set_allocated_credit_card(
      ::oteldemo::CreditCardInfo* credit_card);
  ::oteldemo::CreditCardInfo* unsafe_arena_release_credit_card();

  // @@protoc_insertion_point(class_scope:oteldemo.ChargeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::oteldemo::Money* amount_;
    ::oteldemo::CreditCardInfo* credit_card_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class ChargeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.ChargeResponse) */ {
 public:
  inline ChargeResponse() : ChargeResponse(nullptr) {}
  ~ChargeResponse() override;
  explicit PROTOBUF_CONSTEXPR ChargeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChargeResponse(const ChargeResponse& from);
  ChargeResponse(ChargeResponse&& from) noexcept
    : ChargeResponse() {
    *this = ::std::move(from);
  }

  inline ChargeResponse& operator=(const ChargeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChargeResponse& operator=(ChargeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChargeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChargeResponse* internal_default_instance() {
    return reinterpret_cast<const ChargeResponse*>(
               &_ChargeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ChargeResponse& a, ChargeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ChargeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChargeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChargeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChargeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChargeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChargeResponse& from) {
    ChargeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChargeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.ChargeResponse";
  }
  protected:
  explicit ChargeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionIdFieldNumber = 1,
  };
  // string transaction_id = 1;
  void clear_transaction_id();
  const std::string& transaction_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transaction_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transaction_id();
  PROTOBUF_NODISCARD std::string* release_transaction_id();
  void set_allocated_transaction_id(std::string* transaction_id);
  private:
  const std::string& _internal_transaction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transaction_id(const std::string& value);
  std::string* _internal_mutable_transaction_id();
  public:

  // @@protoc_insertion_point(class_scope:oteldemo.ChargeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transaction_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class OrderItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.OrderItem) */ {
 public:
  inline OrderItem() : OrderItem(nullptr) {}
  ~OrderItem() override;
  explicit PROTOBUF_CONSTEXPR OrderItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderItem(const OrderItem& from);
  OrderItem(OrderItem&& from) noexcept
    : OrderItem() {
    *this = ::std::move(from);
  }

  inline OrderItem& operator=(const OrderItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderItem& operator=(OrderItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderItem* internal_default_instance() {
    return reinterpret_cast<const OrderItem*>(
               &_OrderItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(OrderItem& a, OrderItem& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderItem& from) {
    OrderItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.OrderItem";
  }
  protected:
  explicit OrderItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
    kCostFieldNumber = 2,
  };
  // .oteldemo.CartItem item = 1;
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::oteldemo::CartItem& item() const;
  PROTOBUF_NODISCARD ::oteldemo::CartItem* release_item();
  ::oteldemo::CartItem* mutable_item();
  void set_allocated_item(::oteldemo::CartItem* item);
  private:
  const ::oteldemo::CartItem& _internal_item() const;
  ::oteldemo::CartItem* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::oteldemo::CartItem* item);
  ::oteldemo::CartItem* unsafe_arena_release_item();

  // .oteldemo.Money cost = 2;
  bool has_cost() const;
  private:
  bool _internal_has_cost() const;
  public:
  void clear_cost();
  const ::oteldemo::Money& cost() const;
  PROTOBUF_NODISCARD ::oteldemo::Money* release_cost();
  ::oteldemo::Money* mutable_cost();
  void set_allocated_cost(::oteldemo::Money* cost);
  private:
  const ::oteldemo::Money& _internal_cost() const;
  ::oteldemo::Money* _internal_mutable_cost();
  public:
  void unsafe_arena_set_allocated_cost(
      ::oteldemo::Money* cost);
  ::oteldemo::Money* unsafe_arena_release_cost();

  // @@protoc_insertion_point(class_scope:oteldemo.OrderItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::oteldemo::CartItem* item_;
    ::oteldemo::Money* cost_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class OrderResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.OrderResult) */ {
 public:
  inline OrderResult() : OrderResult(nullptr) {}
  ~OrderResult() override;
  explicit PROTOBUF_CONSTEXPR OrderResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderResult(const OrderResult& from);
  OrderResult(OrderResult&& from) noexcept
    : OrderResult() {
    *this = ::std::move(from);
  }

  inline OrderResult& operator=(const OrderResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderResult& operator=(OrderResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderResult* internal_default_instance() {
    return reinterpret_cast<const OrderResult*>(
               &_OrderResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(OrderResult& a, OrderResult& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderResult& from) {
    OrderResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.OrderResult";
  }
  protected:
  explicit OrderResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 5,
    kOrderIdFieldNumber = 1,
    kShippingTrackingIdFieldNumber = 2,
    kShippingCostFieldNumber = 3,
    kShippingAddressFieldNumber = 4,
  };
  // repeated .oteldemo.OrderItem items = 5;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::oteldemo::OrderItem* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::OrderItem >*
      mutable_items();
  private:
  const ::oteldemo::OrderItem& _internal_items(int index) const;
  ::oteldemo::OrderItem* _internal_add_items();
  public:
  const ::oteldemo::OrderItem& items(int index) const;
  ::oteldemo::OrderItem* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::OrderItem >&
      items() const;

  // string order_id = 1;
  void clear_order_id();
  const std::string& order_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_id();
  PROTOBUF_NODISCARD std::string* release_order_id();
  void set_allocated_order_id(std::string* order_id);
  private:
  const std::string& _internal_order_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_id(const std::string& value);
  std::string* _internal_mutable_order_id();
  public:

  // string shipping_tracking_id = 2;
  void clear_shipping_tracking_id();
  const std::string& shipping_tracking_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_shipping_tracking_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_shipping_tracking_id();
  PROTOBUF_NODISCARD std::string* release_shipping_tracking_id();
  void set_allocated_shipping_tracking_id(std::string* shipping_tracking_id);
  private:
  const std::string& _internal_shipping_tracking_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shipping_tracking_id(const std::string& value);
  std::string* _internal_mutable_shipping_tracking_id();
  public:

  // .oteldemo.Money shipping_cost = 3;
  bool has_shipping_cost() const;
  private:
  bool _internal_has_shipping_cost() const;
  public:
  void clear_shipping_cost();
  const ::oteldemo::Money& shipping_cost() const;
  PROTOBUF_NODISCARD ::oteldemo::Money* release_shipping_cost();
  ::oteldemo::Money* mutable_shipping_cost();
  void set_allocated_shipping_cost(::oteldemo::Money* shipping_cost);
  private:
  const ::oteldemo::Money& _internal_shipping_cost() const;
  ::oteldemo::Money* _internal_mutable_shipping_cost();
  public:
  void unsafe_arena_set_allocated_shipping_cost(
      ::oteldemo::Money* shipping_cost);
  ::oteldemo::Money* unsafe_arena_release_shipping_cost();

  // .oteldemo.Address shipping_address = 4;
  bool has_shipping_address() const;
  private:
  bool _internal_has_shipping_address() const;
  public:
  void clear_shipping_address();
  const ::oteldemo::Address& shipping_address() const;
  PROTOBUF_NODISCARD ::oteldemo::Address* release_shipping_address();
  ::oteldemo::Address* mutable_shipping_address();
  void set_allocated_shipping_address(::oteldemo::Address* shipping_address);
  private:
  const ::oteldemo::Address& _internal_shipping_address() const;
  ::oteldemo::Address* _internal_mutable_shipping_address();
  public:
  void unsafe_arena_set_allocated_shipping_address(
      ::oteldemo::Address* shipping_address);
  ::oteldemo::Address* unsafe_arena_release_shipping_address();

  // @@protoc_insertion_point(class_scope:oteldemo.OrderResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::OrderItem > items_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shipping_tracking_id_;
    ::oteldemo::Money* shipping_cost_;
    ::oteldemo::Address* shipping_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class SendOrderConfirmationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.SendOrderConfirmationRequest) */ {
 public:
  inline SendOrderConfirmationRequest() : SendOrderConfirmationRequest(nullptr) {}
  ~SendOrderConfirmationRequest() override;
  explicit PROTOBUF_CONSTEXPR SendOrderConfirmationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendOrderConfirmationRequest(const SendOrderConfirmationRequest& from);
  SendOrderConfirmationRequest(SendOrderConfirmationRequest&& from) noexcept
    : SendOrderConfirmationRequest() {
    *this = ::std::move(from);
  }

  inline SendOrderConfirmationRequest& operator=(const SendOrderConfirmationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendOrderConfirmationRequest& operator=(SendOrderConfirmationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendOrderConfirmationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendOrderConfirmationRequest* internal_default_instance() {
    return reinterpret_cast<const SendOrderConfirmationRequest*>(
               &_SendOrderConfirmationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SendOrderConfirmationRequest& a, SendOrderConfirmationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SendOrderConfirmationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendOrderConfirmationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendOrderConfirmationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendOrderConfirmationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendOrderConfirmationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendOrderConfirmationRequest& from) {
    SendOrderConfirmationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendOrderConfirmationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.SendOrderConfirmationRequest";
  }
  protected:
  explicit SendOrderConfirmationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  // string email = 1;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // .oteldemo.OrderResult order = 2;
  bool has_order() const;
  private:
  bool _internal_has_order() const;
  public:
  void clear_order();
  const ::oteldemo::OrderResult& order() const;
  PROTOBUF_NODISCARD ::oteldemo::OrderResult* release_order();
  ::oteldemo::OrderResult* mutable_order();
  void set_allocated_order(::oteldemo::OrderResult* order);
  private:
  const ::oteldemo::OrderResult& _internal_order() const;
  ::oteldemo::OrderResult* _internal_mutable_order();
  public:
  void unsafe_arena_set_allocated_order(
      ::oteldemo::OrderResult* order);
  ::oteldemo::OrderResult* unsafe_arena_release_order();

  // @@protoc_insertion_point(class_scope:oteldemo.SendOrderConfirmationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    ::oteldemo::OrderResult* order_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class PlaceOrderRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.PlaceOrderRequest) */ {
 public:
  inline PlaceOrderRequest() : PlaceOrderRequest(nullptr) {}
  ~PlaceOrderRequest() override;
  explicit PROTOBUF_CONSTEXPR PlaceOrderRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlaceOrderRequest(const PlaceOrderRequest& from);
  PlaceOrderRequest(PlaceOrderRequest&& from) noexcept
    : PlaceOrderRequest() {
    *this = ::std::move(from);
  }

  inline PlaceOrderRequest& operator=(const PlaceOrderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlaceOrderRequest& operator=(PlaceOrderRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlaceOrderRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlaceOrderRequest* internal_default_instance() {
    return reinterpret_cast<const PlaceOrderRequest*>(
               &_PlaceOrderRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(PlaceOrderRequest& a, PlaceOrderRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PlaceOrderRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlaceOrderRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlaceOrderRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlaceOrderRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlaceOrderRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlaceOrderRequest& from) {
    PlaceOrderRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlaceOrderRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.PlaceOrderRequest";
  }
  protected:
  explicit PlaceOrderRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kUserCurrencyFieldNumber = 2,
    kEmailFieldNumber = 5,
    kAddressFieldNumber = 3,
    kCreditCardFieldNumber = 6,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string user_currency = 2;
  void clear_user_currency();
  const std::string& user_currency() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_currency(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_currency();
  PROTOBUF_NODISCARD std::string* release_user_currency();
  void set_allocated_user_currency(std::string* user_currency);
  private:
  const std::string& _internal_user_currency() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_currency(const std::string& value);
  std::string* _internal_mutable_user_currency();
  public:

  // string email = 5;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // .oteldemo.Address address = 3;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const ::oteldemo::Address& address() const;
  PROTOBUF_NODISCARD ::oteldemo::Address* release_address();
  ::oteldemo::Address* mutable_address();
  void set_allocated_address(::oteldemo::Address* address);
  private:
  const ::oteldemo::Address& _internal_address() const;
  ::oteldemo::Address* _internal_mutable_address();
  public:
  void unsafe_arena_set_allocated_address(
      ::oteldemo::Address* address);
  ::oteldemo::Address* unsafe_arena_release_address();

  // .oteldemo.CreditCardInfo credit_card = 6;
  bool has_credit_card() const;
  private:
  bool _internal_has_credit_card() const;
  public:
  void clear_credit_card();
  const ::oteldemo::CreditCardInfo& credit_card() const;
  PROTOBUF_NODISCARD ::oteldemo::CreditCardInfo* release_credit_card();
  ::oteldemo::CreditCardInfo* mutable_credit_card();
  void set_allocated_credit_card(::oteldemo::CreditCardInfo* credit_card);
  private:
  const ::oteldemo::CreditCardInfo& _internal_credit_card() const;
  ::oteldemo::CreditCardInfo* _internal_mutable_credit_card();
  public:
  void unsafe_arena_set_allocated_credit_card(
      ::oteldemo::CreditCardInfo* credit_card);
  ::oteldemo::CreditCardInfo* unsafe_arena_release_credit_card();

  // @@protoc_insertion_point(class_scope:oteldemo.PlaceOrderRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_currency_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    ::oteldemo::Address* address_;
    ::oteldemo::CreditCardInfo* credit_card_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class PlaceOrderResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.PlaceOrderResponse) */ {
 public:
  inline PlaceOrderResponse() : PlaceOrderResponse(nullptr) {}
  ~PlaceOrderResponse() override;
  explicit PROTOBUF_CONSTEXPR PlaceOrderResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlaceOrderResponse(const PlaceOrderResponse& from);
  PlaceOrderResponse(PlaceOrderResponse&& from) noexcept
    : PlaceOrderResponse() {
    *this = ::std::move(from);
  }

  inline PlaceOrderResponse& operator=(const PlaceOrderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlaceOrderResponse& operator=(PlaceOrderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlaceOrderResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlaceOrderResponse* internal_default_instance() {
    return reinterpret_cast<const PlaceOrderResponse*>(
               &_PlaceOrderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(PlaceOrderResponse& a, PlaceOrderResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PlaceOrderResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlaceOrderResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlaceOrderResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlaceOrderResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlaceOrderResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlaceOrderResponse& from) {
    PlaceOrderResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlaceOrderResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.PlaceOrderResponse";
  }
  protected:
  explicit PlaceOrderResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderFieldNumber = 1,
  };
  // .oteldemo.OrderResult order = 1;
  bool has_order() const;
  private:
  bool _internal_has_order() const;
  public:
  void clear_order();
  const ::oteldemo::OrderResult& order() const;
  PROTOBUF_NODISCARD ::oteldemo::OrderResult* release_order();
  ::oteldemo::OrderResult* mutable_order();
  void set_allocated_order(::oteldemo::OrderResult* order);
  private:
  const ::oteldemo::OrderResult& _internal_order() const;
  ::oteldemo::OrderResult* _internal_mutable_order();
  public:
  void unsafe_arena_set_allocated_order(
      ::oteldemo::OrderResult* order);
  ::oteldemo::OrderResult* unsafe_arena_release_order();

  // @@protoc_insertion_point(class_scope:oteldemo.PlaceOrderResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::oteldemo::OrderResult* order_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class AdRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.AdRequest) */ {
 public:
  inline AdRequest() : AdRequest(nullptr) {}
  ~AdRequest() override;
  explicit PROTOBUF_CONSTEXPR AdRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdRequest(const AdRequest& from);
  AdRequest(AdRequest&& from) noexcept
    : AdRequest() {
    *this = ::std::move(from);
  }

  inline AdRequest& operator=(const AdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdRequest& operator=(AdRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdRequest* internal_default_instance() {
    return reinterpret_cast<const AdRequest*>(
               &_AdRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(AdRequest& a, AdRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AdRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AdRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AdRequest& from) {
    AdRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.AdRequest";
  }
  protected:
  explicit AdRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContextKeysFieldNumber = 1,
  };
  // repeated string context_keys = 1;
  int context_keys_size() const;
  private:
  int _internal_context_keys_size() const;
  public:
  void clear_context_keys();
  const std::string& context_keys(int index) const;
  std::string* mutable_context_keys(int index);
  void set_context_keys(int index, const std::string& value);
  void set_context_keys(int index, std::string&& value);
  void set_context_keys(int index, const char* value);
  void set_context_keys(int index, const char* value, size_t size);
  std::string* add_context_keys();
  void add_context_keys(const std::string& value);
  void add_context_keys(std::string&& value);
  void add_context_keys(const char* value);
  void add_context_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& context_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_context_keys();
  private:
  const std::string& _internal_context_keys(int index) const;
  std::string* _internal_add_context_keys();
  public:

  // @@protoc_insertion_point(class_scope:oteldemo.AdRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> context_keys_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class AdResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.AdResponse) */ {
 public:
  inline AdResponse() : AdResponse(nullptr) {}
  ~AdResponse() override;
  explicit PROTOBUF_CONSTEXPR AdResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdResponse(const AdResponse& from);
  AdResponse(AdResponse&& from) noexcept
    : AdResponse() {
    *this = ::std::move(from);
  }

  inline AdResponse& operator=(const AdResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdResponse& operator=(AdResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdResponse* internal_default_instance() {
    return reinterpret_cast<const AdResponse*>(
               &_AdResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(AdResponse& a, AdResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AdResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AdResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AdResponse& from) {
    AdResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.AdResponse";
  }
  protected:
  explicit AdResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdsFieldNumber = 1,
  };
  // repeated .oteldemo.Ad ads = 1;
  int ads_size() const;
  private:
  int _internal_ads_size() const;
  public:
  void clear_ads();
  ::oteldemo::Ad* mutable_ads(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::Ad >*
      mutable_ads();
  private:
  const ::oteldemo::Ad& _internal_ads(int index) const;
  ::oteldemo::Ad* _internal_add_ads();
  public:
  const ::oteldemo::Ad& ads(int index) const;
  ::oteldemo::Ad* add_ads();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::Ad >&
      ads() const;

  // @@protoc_insertion_point(class_scope:oteldemo.AdResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::Ad > ads_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class Ad final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.Ad) */ {
 public:
  inline Ad() : Ad(nullptr) {}
  ~Ad() override;
  explicit PROTOBUF_CONSTEXPR Ad(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ad(const Ad& from);
  Ad(Ad&& from) noexcept
    : Ad() {
    *this = ::std::move(from);
  }

  inline Ad& operator=(const Ad& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ad& operator=(Ad&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ad& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ad* internal_default_instance() {
    return reinterpret_cast<const Ad*>(
               &_Ad_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(Ad& a, Ad& b) {
    a.Swap(&b);
  }
  inline void Swap(Ad* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ad* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ad* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ad>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ad& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Ad& from) {
    Ad::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ad* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.Ad";
  }
  protected:
  explicit Ad(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRedirectUrlFieldNumber = 1,
    kTextFieldNumber = 2,
  };
  // string redirect_url = 1;
  void clear_redirect_url();
  const std::string& redirect_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_redirect_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_redirect_url();
  PROTOBUF_NODISCARD std::string* release_redirect_url();
  void set_allocated_redirect_url(std::string* redirect_url);
  private:
  const std::string& _internal_redirect_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_redirect_url(const std::string& value);
  std::string* _internal_mutable_redirect_url();
  public:

  // string text = 2;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // @@protoc_insertion_point(class_scope:oteldemo.Ad)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr redirect_url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class Flag final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.Flag) */ {
 public:
  inline Flag() : Flag(nullptr) {}
  ~Flag() override;
  explicit PROTOBUF_CONSTEXPR Flag(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Flag(const Flag& from);
  Flag(Flag&& from) noexcept
    : Flag() {
    *this = ::std::move(from);
  }

  inline Flag& operator=(const Flag& from) {
    CopyFrom(from);
    return *this;
  }
  inline Flag& operator=(Flag&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Flag& default_instance() {
    return *internal_default_instance();
  }
  static inline const Flag* internal_default_instance() {
    return reinterpret_cast<const Flag*>(
               &_Flag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(Flag& a, Flag& b) {
    a.Swap(&b);
  }
  inline void Swap(Flag* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Flag* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Flag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Flag>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Flag& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Flag& from) {
    Flag::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Flag* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.Flag";
  }
  protected:
  explicit Flag(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kEnabledFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // bool enabled = 3;
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:oteldemo.Flag)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    bool enabled_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class GetFlagRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.GetFlagRequest) */ {
 public:
  inline GetFlagRequest() : GetFlagRequest(nullptr) {}
  ~GetFlagRequest() override;
  explicit PROTOBUF_CONSTEXPR GetFlagRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFlagRequest(const GetFlagRequest& from);
  GetFlagRequest(GetFlagRequest&& from) noexcept
    : GetFlagRequest() {
    *this = ::std::move(from);
  }

  inline GetFlagRequest& operator=(const GetFlagRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFlagRequest& operator=(GetFlagRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFlagRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFlagRequest* internal_default_instance() {
    return reinterpret_cast<const GetFlagRequest*>(
               &_GetFlagRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(GetFlagRequest& a, GetFlagRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFlagRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFlagRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFlagRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFlagRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFlagRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetFlagRequest& from) {
    GetFlagRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFlagRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.GetFlagRequest";
  }
  protected:
  explicit GetFlagRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:oteldemo.GetFlagRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class GetFlagResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.GetFlagResponse) */ {
 public:
  inline GetFlagResponse() : GetFlagResponse(nullptr) {}
  ~GetFlagResponse() override;
  explicit PROTOBUF_CONSTEXPR GetFlagResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFlagResponse(const GetFlagResponse& from);
  GetFlagResponse(GetFlagResponse&& from) noexcept
    : GetFlagResponse() {
    *this = ::std::move(from);
  }

  inline GetFlagResponse& operator=(const GetFlagResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFlagResponse& operator=(GetFlagResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFlagResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFlagResponse* internal_default_instance() {
    return reinterpret_cast<const GetFlagResponse*>(
               &_GetFlagResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(GetFlagResponse& a, GetFlagResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFlagResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFlagResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFlagResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFlagResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFlagResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetFlagResponse& from) {
    GetFlagResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFlagResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.GetFlagResponse";
  }
  protected:
  explicit GetFlagResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlagFieldNumber = 1,
  };
  // .oteldemo.Flag flag = 1;
  bool has_flag() const;
  private:
  bool _internal_has_flag() const;
  public:
  void clear_flag();
  const ::oteldemo::Flag& flag() const;
  PROTOBUF_NODISCARD ::oteldemo::Flag* release_flag();
  ::oteldemo::Flag* mutable_flag();
  void set_allocated_flag(::oteldemo::Flag* flag);
  private:
  const ::oteldemo::Flag& _internal_flag() const;
  ::oteldemo::Flag* _internal_mutable_flag();
  public:
  void unsafe_arena_set_allocated_flag(
      ::oteldemo::Flag* flag);
  ::oteldemo::Flag* unsafe_arena_release_flag();

  // @@protoc_insertion_point(class_scope:oteldemo.GetFlagResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::oteldemo::Flag* flag_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class CreateFlagRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.CreateFlagRequest) */ {
 public:
  inline CreateFlagRequest() : CreateFlagRequest(nullptr) {}
  ~CreateFlagRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateFlagRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateFlagRequest(const CreateFlagRequest& from);
  CreateFlagRequest(CreateFlagRequest&& from) noexcept
    : CreateFlagRequest() {
    *this = ::std::move(from);
  }

  inline CreateFlagRequest& operator=(const CreateFlagRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateFlagRequest& operator=(CreateFlagRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateFlagRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateFlagRequest* internal_default_instance() {
    return reinterpret_cast<const CreateFlagRequest*>(
               &_CreateFlagRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(CreateFlagRequest& a, CreateFlagRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateFlagRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateFlagRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateFlagRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateFlagRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateFlagRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateFlagRequest& from) {
    CreateFlagRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateFlagRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.CreateFlagRequest";
  }
  protected:
  explicit CreateFlagRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kEnabledFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // bool enabled = 3;
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:oteldemo.CreateFlagRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    bool enabled_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class CreateFlagResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.CreateFlagResponse) */ {
 public:
  inline CreateFlagResponse() : CreateFlagResponse(nullptr) {}
  ~CreateFlagResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateFlagResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateFlagResponse(const CreateFlagResponse& from);
  CreateFlagResponse(CreateFlagResponse&& from) noexcept
    : CreateFlagResponse() {
    *this = ::std::move(from);
  }

  inline CreateFlagResponse& operator=(const CreateFlagResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateFlagResponse& operator=(CreateFlagResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateFlagResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateFlagResponse* internal_default_instance() {
    return reinterpret_cast<const CreateFlagResponse*>(
               &_CreateFlagResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(CreateFlagResponse& a, CreateFlagResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateFlagResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateFlagResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateFlagResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateFlagResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateFlagResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateFlagResponse& from) {
    CreateFlagResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateFlagResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.CreateFlagResponse";
  }
  protected:
  explicit CreateFlagResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlagFieldNumber = 1,
  };
  // .oteldemo.Flag flag = 1;
  bool has_flag() const;
  private:
  bool _internal_has_flag() const;
  public:
  void clear_flag();
  const ::oteldemo::Flag& flag() const;
  PROTOBUF_NODISCARD ::oteldemo::Flag* release_flag();
  ::oteldemo::Flag* mutable_flag();
  void set_allocated_flag(::oteldemo::Flag* flag);
  private:
  const ::oteldemo::Flag& _internal_flag() const;
  ::oteldemo::Flag* _internal_mutable_flag();
  public:
  void unsafe_arena_set_allocated_flag(
      ::oteldemo::Flag* flag);
  ::oteldemo::Flag* unsafe_arena_release_flag();

  // @@protoc_insertion_point(class_scope:oteldemo.CreateFlagResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::oteldemo::Flag* flag_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class UpdateFlagRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.UpdateFlagRequest) */ {
 public:
  inline UpdateFlagRequest() : UpdateFlagRequest(nullptr) {}
  ~UpdateFlagRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateFlagRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateFlagRequest(const UpdateFlagRequest& from);
  UpdateFlagRequest(UpdateFlagRequest&& from) noexcept
    : UpdateFlagRequest() {
    *this = ::std::move(from);
  }

  inline UpdateFlagRequest& operator=(const UpdateFlagRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateFlagRequest& operator=(UpdateFlagRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateFlagRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateFlagRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateFlagRequest*>(
               &_UpdateFlagRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(UpdateFlagRequest& a, UpdateFlagRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateFlagRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateFlagRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateFlagRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateFlagRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateFlagRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateFlagRequest& from) {
    UpdateFlagRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateFlagRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.UpdateFlagRequest";
  }
  protected:
  explicit UpdateFlagRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kEnabledFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bool enabled = 2;
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:oteldemo.UpdateFlagRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    bool enabled_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class UpdateFlagResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:oteldemo.UpdateFlagResponse) */ {
 public:
  inline UpdateFlagResponse() : UpdateFlagResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UpdateFlagResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateFlagResponse(const UpdateFlagResponse& from);
  UpdateFlagResponse(UpdateFlagResponse&& from) noexcept
    : UpdateFlagResponse() {
    *this = ::std::move(from);
  }

  inline UpdateFlagResponse& operator=(const UpdateFlagResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateFlagResponse& operator=(UpdateFlagResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateFlagResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateFlagResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateFlagResponse*>(
               &_UpdateFlagResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(UpdateFlagResponse& a, UpdateFlagResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateFlagResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateFlagResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateFlagResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateFlagResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateFlagResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateFlagResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.UpdateFlagResponse";
  }
  protected:
  explicit UpdateFlagResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:oteldemo.UpdateFlagResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class ListFlagsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:oteldemo.ListFlagsRequest) */ {
 public:
  inline ListFlagsRequest() : ListFlagsRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ListFlagsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListFlagsRequest(const ListFlagsRequest& from);
  ListFlagsRequest(ListFlagsRequest&& from) noexcept
    : ListFlagsRequest() {
    *this = ::std::move(from);
  }

  inline ListFlagsRequest& operator=(const ListFlagsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListFlagsRequest& operator=(ListFlagsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListFlagsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListFlagsRequest* internal_default_instance() {
    return reinterpret_cast<const ListFlagsRequest*>(
               &_ListFlagsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(ListFlagsRequest& a, ListFlagsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListFlagsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListFlagsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListFlagsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListFlagsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ListFlagsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ListFlagsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.ListFlagsRequest";
  }
  protected:
  explicit ListFlagsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:oteldemo.ListFlagsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class ListFlagsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.ListFlagsResponse) */ {
 public:
  inline ListFlagsResponse() : ListFlagsResponse(nullptr) {}
  ~ListFlagsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListFlagsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListFlagsResponse(const ListFlagsResponse& from);
  ListFlagsResponse(ListFlagsResponse&& from) noexcept
    : ListFlagsResponse() {
    *this = ::std::move(from);
  }

  inline ListFlagsResponse& operator=(const ListFlagsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListFlagsResponse& operator=(ListFlagsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListFlagsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListFlagsResponse* internal_default_instance() {
    return reinterpret_cast<const ListFlagsResponse*>(
               &_ListFlagsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(ListFlagsResponse& a, ListFlagsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListFlagsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListFlagsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListFlagsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListFlagsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListFlagsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListFlagsResponse& from) {
    ListFlagsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListFlagsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.ListFlagsResponse";
  }
  protected:
  explicit ListFlagsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlagFieldNumber = 1,
  };
  // repeated .oteldemo.Flag flag = 1;
  int flag_size() const;
  private:
  int _internal_flag_size() const;
  public:
  void clear_flag();
  ::oteldemo::Flag* mutable_flag(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::Flag >*
      mutable_flag();
  private:
  const ::oteldemo::Flag& _internal_flag(int index) const;
  ::oteldemo::Flag* _internal_add_flag();
  public:
  const ::oteldemo::Flag& flag(int index) const;
  ::oteldemo::Flag* add_flag();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::Flag >&
      flag() const;

  // @@protoc_insertion_point(class_scope:oteldemo.ListFlagsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::Flag > flag_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class DeleteFlagRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oteldemo.DeleteFlagRequest) */ {
 public:
  inline DeleteFlagRequest() : DeleteFlagRequest(nullptr) {}
  ~DeleteFlagRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteFlagRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteFlagRequest(const DeleteFlagRequest& from);
  DeleteFlagRequest(DeleteFlagRequest&& from) noexcept
    : DeleteFlagRequest() {
    *this = ::std::move(from);
  }

  inline DeleteFlagRequest& operator=(const DeleteFlagRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteFlagRequest& operator=(DeleteFlagRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteFlagRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteFlagRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteFlagRequest*>(
               &_DeleteFlagRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(DeleteFlagRequest& a, DeleteFlagRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteFlagRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteFlagRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteFlagRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteFlagRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteFlagRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteFlagRequest& from) {
    DeleteFlagRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteFlagRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.DeleteFlagRequest";
  }
  protected:
  explicit DeleteFlagRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:oteldemo.DeleteFlagRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_demo_2eproto;
};
// -------------------------------------------------------------------

class DeleteFlagResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:oteldemo.DeleteFlagResponse) */ {
 public:
  inline DeleteFlagResponse() : DeleteFlagResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteFlagResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteFlagResponse(const DeleteFlagResponse& from);
  DeleteFlagResponse(DeleteFlagResponse&& from) noexcept
    : DeleteFlagResponse() {
    *this = ::std::move(from);
  }

  inline DeleteFlagResponse& operator=(const DeleteFlagResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteFlagResponse& operator=(DeleteFlagResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteFlagResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteFlagResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteFlagResponse*>(
               &_DeleteFlagResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(DeleteFlagResponse& a, DeleteFlagResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteFlagResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteFlagResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteFlagResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteFlagResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteFlagResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteFlagResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oteldemo.DeleteFlagResponse";
  }
  protected:
  explicit DeleteFlagResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:oteldemo.DeleteFlagResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_demo_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CartItem

// string product_id = 1;
inline void CartItem::clear_product_id() {
  _impl_.product_id_.ClearToEmpty();
}
inline const std::string& CartItem::product_id() const {
  // @@protoc_insertion_point(field_get:oteldemo.CartItem.product_id)
  return _internal_product_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CartItem::set_product_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.product_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.CartItem.product_id)
}
inline std::string* CartItem::mutable_product_id() {
  std::string* _s = _internal_mutable_product_id();
  // @@protoc_insertion_point(field_mutable:oteldemo.CartItem.product_id)
  return _s;
}
inline const std::string& CartItem::_internal_product_id() const {
  return _impl_.product_id_.Get();
}
inline void CartItem::_internal_set_product_id(const std::string& value) {
  
  _impl_.product_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CartItem::_internal_mutable_product_id() {
  
  return _impl_.product_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CartItem::release_product_id() {
  // @@protoc_insertion_point(field_release:oteldemo.CartItem.product_id)
  return _impl_.product_id_.Release();
}
inline void CartItem::set_allocated_product_id(std::string* product_id) {
  if (product_id != nullptr) {
    
  } else {
    
  }
  _impl_.product_id_.SetAllocated(product_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.product_id_.IsDefault()) {
    _impl_.product_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.CartItem.product_id)
}

// int32 quantity = 2;
inline void CartItem::clear_quantity() {
  _impl_.quantity_ = 0;
}
inline int32_t CartItem::_internal_quantity() const {
  return _impl_.quantity_;
}
inline int32_t CartItem::quantity() const {
  // @@protoc_insertion_point(field_get:oteldemo.CartItem.quantity)
  return _internal_quantity();
}
inline void CartItem::_internal_set_quantity(int32_t value) {
  
  _impl_.quantity_ = value;
}
inline void CartItem::set_quantity(int32_t value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:oteldemo.CartItem.quantity)
}

// -------------------------------------------------------------------

// AddItemRequest

// string user_id = 1;
inline void AddItemRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& AddItemRequest::user_id() const {
  // @@protoc_insertion_point(field_get:oteldemo.AddItemRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddItemRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.AddItemRequest.user_id)
}
inline std::string* AddItemRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:oteldemo.AddItemRequest.user_id)
  return _s;
}
inline const std::string& AddItemRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void AddItemRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AddItemRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AddItemRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:oteldemo.AddItemRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void AddItemRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.AddItemRequest.user_id)
}

// .oteldemo.CartItem item = 2;
inline bool AddItemRequest::_internal_has_item() const {
  return this != internal_default_instance() && _impl_.item_ != nullptr;
}
inline bool AddItemRequest::has_item() const {
  return _internal_has_item();
}
inline void AddItemRequest::clear_item() {
  if (GetArenaForAllocation() == nullptr && _impl_.item_ != nullptr) {
    delete _impl_.item_;
  }
  _impl_.item_ = nullptr;
}
inline const ::oteldemo::CartItem& AddItemRequest::_internal_item() const {
  const ::oteldemo::CartItem* p = _impl_.item_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::CartItem&>(
      ::oteldemo::_CartItem_default_instance_);
}
inline const ::oteldemo::CartItem& AddItemRequest::item() const {
  // @@protoc_insertion_point(field_get:oteldemo.AddItemRequest.item)
  return _internal_item();
}
inline void AddItemRequest::unsafe_arena_set_allocated_item(
    ::oteldemo::CartItem* item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.item_);
  }
  _impl_.item_ = item;
  if (item) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.AddItemRequest.item)
}
inline ::oteldemo::CartItem* AddItemRequest::release_item() {
  
  ::oteldemo::CartItem* temp = _impl_.item_;
  _impl_.item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::oteldemo::CartItem* AddItemRequest::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_release:oteldemo.AddItemRequest.item)
  
  ::oteldemo::CartItem* temp = _impl_.item_;
  _impl_.item_ = nullptr;
  return temp;
}
inline ::oteldemo::CartItem* AddItemRequest::_internal_mutable_item() {
  
  if (_impl_.item_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::CartItem>(GetArenaForAllocation());
    _impl_.item_ = p;
  }
  return _impl_.item_;
}
inline ::oteldemo::CartItem* AddItemRequest::mutable_item() {
  ::oteldemo::CartItem* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:oteldemo.AddItemRequest.item)
  return _msg;
}
inline void AddItemRequest::set_allocated_item(::oteldemo::CartItem* item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.item_;
  }
  if (item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(item);
    if (message_arena != submessage_arena) {
      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.item_ = item;
  // @@protoc_insertion_point(field_set_allocated:oteldemo.AddItemRequest.item)
}

// -------------------------------------------------------------------

// EmptyCartRequest

// string user_id = 1;
inline void EmptyCartRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& EmptyCartRequest::user_id() const {
  // @@protoc_insertion_point(field_get:oteldemo.EmptyCartRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EmptyCartRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.EmptyCartRequest.user_id)
}
inline std::string* EmptyCartRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:oteldemo.EmptyCartRequest.user_id)
  return _s;
}
inline const std::string& EmptyCartRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void EmptyCartRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EmptyCartRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* EmptyCartRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:oteldemo.EmptyCartRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void EmptyCartRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.EmptyCartRequest.user_id)
}

// -------------------------------------------------------------------

// GetCartRequest

// string user_id = 1;
inline void GetCartRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& GetCartRequest::user_id() const {
  // @@protoc_insertion_point(field_get:oteldemo.GetCartRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetCartRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.GetCartRequest.user_id)
}
inline std::string* GetCartRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:oteldemo.GetCartRequest.user_id)
  return _s;
}
inline const std::string& GetCartRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void GetCartRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetCartRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetCartRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:oteldemo.GetCartRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void GetCartRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.GetCartRequest.user_id)
}

// -------------------------------------------------------------------

// Cart

// string user_id = 1;
inline void Cart::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& Cart::user_id() const {
  // @@protoc_insertion_point(field_get:oteldemo.Cart.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Cart::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.Cart.user_id)
}
inline std::string* Cart::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:oteldemo.Cart.user_id)
  return _s;
}
inline const std::string& Cart::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void Cart::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Cart::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Cart::release_user_id() {
  // @@protoc_insertion_point(field_release:oteldemo.Cart.user_id)
  return _impl_.user_id_.Release();
}
inline void Cart::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.Cart.user_id)
}

// repeated .oteldemo.CartItem items = 2;
inline int Cart::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int Cart::items_size() const {
  return _internal_items_size();
}
inline void Cart::clear_items() {
  _impl_.items_.Clear();
}
inline ::oteldemo::CartItem* Cart::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:oteldemo.Cart.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::CartItem >*
Cart::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:oteldemo.Cart.items)
  return &_impl_.items_;
}
inline const ::oteldemo::CartItem& Cart::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::oteldemo::CartItem& Cart::items(int index) const {
  // @@protoc_insertion_point(field_get:oteldemo.Cart.items)
  return _internal_items(index);
}
inline ::oteldemo::CartItem* Cart::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::oteldemo::CartItem* Cart::add_items() {
  ::oteldemo::CartItem* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:oteldemo.Cart.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::CartItem >&
Cart::items() const {
  // @@protoc_insertion_point(field_list:oteldemo.Cart.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// Empty

// -------------------------------------------------------------------

// ListRecommendationsRequest

// string user_id = 1;
inline void ListRecommendationsRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& ListRecommendationsRequest::user_id() const {
  // @@protoc_insertion_point(field_get:oteldemo.ListRecommendationsRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListRecommendationsRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.ListRecommendationsRequest.user_id)
}
inline std::string* ListRecommendationsRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:oteldemo.ListRecommendationsRequest.user_id)
  return _s;
}
inline const std::string& ListRecommendationsRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void ListRecommendationsRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListRecommendationsRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListRecommendationsRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:oteldemo.ListRecommendationsRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void ListRecommendationsRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.ListRecommendationsRequest.user_id)
}

// repeated string product_ids = 2;
inline int ListRecommendationsRequest::_internal_product_ids_size() const {
  return _impl_.product_ids_.size();
}
inline int ListRecommendationsRequest::product_ids_size() const {
  return _internal_product_ids_size();
}
inline void ListRecommendationsRequest::clear_product_ids() {
  _impl_.product_ids_.Clear();
}
inline std::string* ListRecommendationsRequest::add_product_ids() {
  std::string* _s = _internal_add_product_ids();
  // @@protoc_insertion_point(field_add_mutable:oteldemo.ListRecommendationsRequest.product_ids)
  return _s;
}
inline const std::string& ListRecommendationsRequest::_internal_product_ids(int index) const {
  return _impl_.product_ids_.Get(index);
}
inline const std::string& ListRecommendationsRequest::product_ids(int index) const {
  // @@protoc_insertion_point(field_get:oteldemo.ListRecommendationsRequest.product_ids)
  return _internal_product_ids(index);
}
inline std::string* ListRecommendationsRequest::mutable_product_ids(int index) {
  // @@protoc_insertion_point(field_mutable:oteldemo.ListRecommendationsRequest.product_ids)
  return _impl_.product_ids_.Mutable(index);
}
inline void ListRecommendationsRequest::set_product_ids(int index, const std::string& value) {
  _impl_.product_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:oteldemo.ListRecommendationsRequest.product_ids)
}
inline void ListRecommendationsRequest::set_product_ids(int index, std::string&& value) {
  _impl_.product_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:oteldemo.ListRecommendationsRequest.product_ids)
}
inline void ListRecommendationsRequest::set_product_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.product_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:oteldemo.ListRecommendationsRequest.product_ids)
}
inline void ListRecommendationsRequest::set_product_ids(int index, const char* value, size_t size) {
  _impl_.product_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:oteldemo.ListRecommendationsRequest.product_ids)
}
inline std::string* ListRecommendationsRequest::_internal_add_product_ids() {
  return _impl_.product_ids_.Add();
}
inline void ListRecommendationsRequest::add_product_ids(const std::string& value) {
  _impl_.product_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:oteldemo.ListRecommendationsRequest.product_ids)
}
inline void ListRecommendationsRequest::add_product_ids(std::string&& value) {
  _impl_.product_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:oteldemo.ListRecommendationsRequest.product_ids)
}
inline void ListRecommendationsRequest::add_product_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.product_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:oteldemo.ListRecommendationsRequest.product_ids)
}
inline void ListRecommendationsRequest::add_product_ids(const char* value, size_t size) {
  _impl_.product_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:oteldemo.ListRecommendationsRequest.product_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListRecommendationsRequest::product_ids() const {
  // @@protoc_insertion_point(field_list:oteldemo.ListRecommendationsRequest.product_ids)
  return _impl_.product_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListRecommendationsRequest::mutable_product_ids() {
  // @@protoc_insertion_point(field_mutable_list:oteldemo.ListRecommendationsRequest.product_ids)
  return &_impl_.product_ids_;
}

// -------------------------------------------------------------------

// ListRecommendationsResponse

// repeated string product_ids = 1;
inline int ListRecommendationsResponse::_internal_product_ids_size() const {
  return _impl_.product_ids_.size();
}
inline int ListRecommendationsResponse::product_ids_size() const {
  return _internal_product_ids_size();
}
inline void ListRecommendationsResponse::clear_product_ids() {
  _impl_.product_ids_.Clear();
}
inline std::string* ListRecommendationsResponse::add_product_ids() {
  std::string* _s = _internal_add_product_ids();
  // @@protoc_insertion_point(field_add_mutable:oteldemo.ListRecommendationsResponse.product_ids)
  return _s;
}
inline const std::string& ListRecommendationsResponse::_internal_product_ids(int index) const {
  return _impl_.product_ids_.Get(index);
}
inline const std::string& ListRecommendationsResponse::product_ids(int index) const {
  // @@protoc_insertion_point(field_get:oteldemo.ListRecommendationsResponse.product_ids)
  return _internal_product_ids(index);
}
inline std::string* ListRecommendationsResponse::mutable_product_ids(int index) {
  // @@protoc_insertion_point(field_mutable:oteldemo.ListRecommendationsResponse.product_ids)
  return _impl_.product_ids_.Mutable(index);
}
inline void ListRecommendationsResponse::set_product_ids(int index, const std::string& value) {
  _impl_.product_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:oteldemo.ListRecommendationsResponse.product_ids)
}
inline void ListRecommendationsResponse::set_product_ids(int index, std::string&& value) {
  _impl_.product_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:oteldemo.ListRecommendationsResponse.product_ids)
}
inline void ListRecommendationsResponse::set_product_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.product_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:oteldemo.ListRecommendationsResponse.product_ids)
}
inline void ListRecommendationsResponse::set_product_ids(int index, const char* value, size_t size) {
  _impl_.product_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:oteldemo.ListRecommendationsResponse.product_ids)
}
inline std::string* ListRecommendationsResponse::_internal_add_product_ids() {
  return _impl_.product_ids_.Add();
}
inline void ListRecommendationsResponse::add_product_ids(const std::string& value) {
  _impl_.product_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:oteldemo.ListRecommendationsResponse.product_ids)
}
inline void ListRecommendationsResponse::add_product_ids(std::string&& value) {
  _impl_.product_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:oteldemo.ListRecommendationsResponse.product_ids)
}
inline void ListRecommendationsResponse::add_product_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.product_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:oteldemo.ListRecommendationsResponse.product_ids)
}
inline void ListRecommendationsResponse::add_product_ids(const char* value, size_t size) {
  _impl_.product_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:oteldemo.ListRecommendationsResponse.product_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListRecommendationsResponse::product_ids() const {
  // @@protoc_insertion_point(field_list:oteldemo.ListRecommendationsResponse.product_ids)
  return _impl_.product_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListRecommendationsResponse::mutable_product_ids() {
  // @@protoc_insertion_point(field_mutable_list:oteldemo.ListRecommendationsResponse.product_ids)
  return &_impl_.product_ids_;
}

// -------------------------------------------------------------------

// Product

// string id = 1;
inline void Product::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Product::id() const {
  // @@protoc_insertion_point(field_get:oteldemo.Product.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Product::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.Product.id)
}
inline std::string* Product::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:oteldemo.Product.id)
  return _s;
}
inline const std::string& Product::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Product::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Product::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Product::release_id() {
  // @@protoc_insertion_point(field_release:oteldemo.Product.id)
  return _impl_.id_.Release();
}
inline void Product::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.Product.id)
}

// string name = 2;
inline void Product::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Product::name() const {
  // @@protoc_insertion_point(field_get:oteldemo.Product.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Product::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.Product.name)
}
inline std::string* Product::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:oteldemo.Product.name)
  return _s;
}
inline const std::string& Product::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Product::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Product::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Product::release_name() {
  // @@protoc_insertion_point(field_release:oteldemo.Product.name)
  return _impl_.name_.Release();
}
inline void Product::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.Product.name)
}

// string description = 3;
inline void Product::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Product::description() const {
  // @@protoc_insertion_point(field_get:oteldemo.Product.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Product::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.Product.description)
}
inline std::string* Product::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:oteldemo.Product.description)
  return _s;
}
inline const std::string& Product::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Product::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Product::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Product::release_description() {
  // @@protoc_insertion_point(field_release:oteldemo.Product.description)
  return _impl_.description_.Release();
}
inline void Product::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.Product.description)
}

// string picture = 4;
inline void Product::clear_picture() {
  _impl_.picture_.ClearToEmpty();
}
inline const std::string& Product::picture() const {
  // @@protoc_insertion_point(field_get:oteldemo.Product.picture)
  return _internal_picture();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Product::set_picture(ArgT0&& arg0, ArgT... args) {
 
 _impl_.picture_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.Product.picture)
}
inline std::string* Product::mutable_picture() {
  std::string* _s = _internal_mutable_picture();
  // @@protoc_insertion_point(field_mutable:oteldemo.Product.picture)
  return _s;
}
inline const std::string& Product::_internal_picture() const {
  return _impl_.picture_.Get();
}
inline void Product::_internal_set_picture(const std::string& value) {
  
  _impl_.picture_.Set(value, GetArenaForAllocation());
}
inline std::string* Product::_internal_mutable_picture() {
  
  return _impl_.picture_.Mutable(GetArenaForAllocation());
}
inline std::string* Product::release_picture() {
  // @@protoc_insertion_point(field_release:oteldemo.Product.picture)
  return _impl_.picture_.Release();
}
inline void Product::set_allocated_picture(std::string* picture) {
  if (picture != nullptr) {
    
  } else {
    
  }
  _impl_.picture_.SetAllocated(picture, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.picture_.IsDefault()) {
    _impl_.picture_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.Product.picture)
}

// .oteldemo.Money price_usd = 5;
inline bool Product::_internal_has_price_usd() const {
  return this != internal_default_instance() && _impl_.price_usd_ != nullptr;
}
inline bool Product::has_price_usd() const {
  return _internal_has_price_usd();
}
inline void Product::clear_price_usd() {
  if (GetArenaForAllocation() == nullptr && _impl_.price_usd_ != nullptr) {
    delete _impl_.price_usd_;
  }
  _impl_.price_usd_ = nullptr;
}
inline const ::oteldemo::Money& Product::_internal_price_usd() const {
  const ::oteldemo::Money* p = _impl_.price_usd_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::Money&>(
      ::oteldemo::_Money_default_instance_);
}
inline const ::oteldemo::Money& Product::price_usd() const {
  // @@protoc_insertion_point(field_get:oteldemo.Product.price_usd)
  return _internal_price_usd();
}
inline void Product::unsafe_arena_set_allocated_price_usd(
    ::oteldemo::Money* price_usd) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.price_usd_);
  }
  _impl_.price_usd_ = price_usd;
  if (price_usd) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.Product.price_usd)
}
inline ::oteldemo::Money* Product::release_price_usd() {
  
  ::oteldemo::Money* temp = _impl_.price_usd_;
  _impl_.price_usd_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::oteldemo::Money* Product::unsafe_arena_release_price_usd() {
  // @@protoc_insertion_point(field_release:oteldemo.Product.price_usd)
  
  ::oteldemo::Money* temp = _impl_.price_usd_;
  _impl_.price_usd_ = nullptr;
  return temp;
}
inline ::oteldemo::Money* Product::_internal_mutable_price_usd() {
  
  if (_impl_.price_usd_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::Money>(GetArenaForAllocation());
    _impl_.price_usd_ = p;
  }
  return _impl_.price_usd_;
}
inline ::oteldemo::Money* Product::mutable_price_usd() {
  ::oteldemo::Money* _msg = _internal_mutable_price_usd();
  // @@protoc_insertion_point(field_mutable:oteldemo.Product.price_usd)
  return _msg;
}
inline void Product::set_allocated_price_usd(::oteldemo::Money* price_usd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.price_usd_;
  }
  if (price_usd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(price_usd);
    if (message_arena != submessage_arena) {
      price_usd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, price_usd, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.price_usd_ = price_usd;
  // @@protoc_insertion_point(field_set_allocated:oteldemo.Product.price_usd)
}

// repeated string categories = 6;
inline int Product::_internal_categories_size() const {
  return _impl_.categories_.size();
}
inline int Product::categories_size() const {
  return _internal_categories_size();
}
inline void Product::clear_categories() {
  _impl_.categories_.Clear();
}
inline std::string* Product::add_categories() {
  std::string* _s = _internal_add_categories();
  // @@protoc_insertion_point(field_add_mutable:oteldemo.Product.categories)
  return _s;
}
inline const std::string& Product::_internal_categories(int index) const {
  return _impl_.categories_.Get(index);
}
inline const std::string& Product::categories(int index) const {
  // @@protoc_insertion_point(field_get:oteldemo.Product.categories)
  return _internal_categories(index);
}
inline std::string* Product::mutable_categories(int index) {
  // @@protoc_insertion_point(field_mutable:oteldemo.Product.categories)
  return _impl_.categories_.Mutable(index);
}
inline void Product::set_categories(int index, const std::string& value) {
  _impl_.categories_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:oteldemo.Product.categories)
}
inline void Product::set_categories(int index, std::string&& value) {
  _impl_.categories_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:oteldemo.Product.categories)
}
inline void Product::set_categories(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.categories_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:oteldemo.Product.categories)
}
inline void Product::set_categories(int index, const char* value, size_t size) {
  _impl_.categories_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:oteldemo.Product.categories)
}
inline std::string* Product::_internal_add_categories() {
  return _impl_.categories_.Add();
}
inline void Product::add_categories(const std::string& value) {
  _impl_.categories_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:oteldemo.Product.categories)
}
inline void Product::add_categories(std::string&& value) {
  _impl_.categories_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:oteldemo.Product.categories)
}
inline void Product::add_categories(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.categories_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:oteldemo.Product.categories)
}
inline void Product::add_categories(const char* value, size_t size) {
  _impl_.categories_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:oteldemo.Product.categories)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Product::categories() const {
  // @@protoc_insertion_point(field_list:oteldemo.Product.categories)
  return _impl_.categories_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Product::mutable_categories() {
  // @@protoc_insertion_point(field_mutable_list:oteldemo.Product.categories)
  return &_impl_.categories_;
}

// -------------------------------------------------------------------

// ListProductsResponse

// repeated .oteldemo.Product products = 1;
inline int ListProductsResponse::_internal_products_size() const {
  return _impl_.products_.size();
}
inline int ListProductsResponse::products_size() const {
  return _internal_products_size();
}
inline void ListProductsResponse::clear_products() {
  _impl_.products_.Clear();
}
inline ::oteldemo::Product* ListProductsResponse::mutable_products(int index) {
  // @@protoc_insertion_point(field_mutable:oteldemo.ListProductsResponse.products)
  return _impl_.products_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::Product >*
ListProductsResponse::mutable_products() {
  // @@protoc_insertion_point(field_mutable_list:oteldemo.ListProductsResponse.products)
  return &_impl_.products_;
}
inline const ::oteldemo::Product& ListProductsResponse::_internal_products(int index) const {
  return _impl_.products_.Get(index);
}
inline const ::oteldemo::Product& ListProductsResponse::products(int index) const {
  // @@protoc_insertion_point(field_get:oteldemo.ListProductsResponse.products)
  return _internal_products(index);
}
inline ::oteldemo::Product* ListProductsResponse::_internal_add_products() {
  return _impl_.products_.Add();
}
inline ::oteldemo::Product* ListProductsResponse::add_products() {
  ::oteldemo::Product* _add = _internal_add_products();
  // @@protoc_insertion_point(field_add:oteldemo.ListProductsResponse.products)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::Product >&
ListProductsResponse::products() const {
  // @@protoc_insertion_point(field_list:oteldemo.ListProductsResponse.products)
  return _impl_.products_;
}

// -------------------------------------------------------------------

// GetProductRequest

// string id = 1;
inline void GetProductRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GetProductRequest::id() const {
  // @@protoc_insertion_point(field_get:oteldemo.GetProductRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetProductRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.GetProductRequest.id)
}
inline std::string* GetProductRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:oteldemo.GetProductRequest.id)
  return _s;
}
inline const std::string& GetProductRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void GetProductRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetProductRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetProductRequest::release_id() {
  // @@protoc_insertion_point(field_release:oteldemo.GetProductRequest.id)
  return _impl_.id_.Release();
}
inline void GetProductRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.GetProductRequest.id)
}

// -------------------------------------------------------------------

// SearchProductsRequest

// string query = 1;
inline void SearchProductsRequest::clear_query() {
  _impl_.query_.ClearToEmpty();
}
inline const std::string& SearchProductsRequest::query() const {
  // @@protoc_insertion_point(field_get:oteldemo.SearchProductsRequest.query)
  return _internal_query();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SearchProductsRequest::set_query(ArgT0&& arg0, ArgT... args) {
 
 _impl_.query_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.SearchProductsRequest.query)
}
inline std::string* SearchProductsRequest::mutable_query() {
  std::string* _s = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:oteldemo.SearchProductsRequest.query)
  return _s;
}
inline const std::string& SearchProductsRequest::_internal_query() const {
  return _impl_.query_.Get();
}
inline void SearchProductsRequest::_internal_set_query(const std::string& value) {
  
  _impl_.query_.Set(value, GetArenaForAllocation());
}
inline std::string* SearchProductsRequest::_internal_mutable_query() {
  
  return _impl_.query_.Mutable(GetArenaForAllocation());
}
inline std::string* SearchProductsRequest::release_query() {
  // @@protoc_insertion_point(field_release:oteldemo.SearchProductsRequest.query)
  return _impl_.query_.Release();
}
inline void SearchProductsRequest::set_allocated_query(std::string* query) {
  if (query != nullptr) {
    
  } else {
    
  }
  _impl_.query_.SetAllocated(query, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.query_.IsDefault()) {
    _impl_.query_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.SearchProductsRequest.query)
}

// -------------------------------------------------------------------

// SearchProductsResponse

// repeated .oteldemo.Product results = 1;
inline int SearchProductsResponse::_internal_results_size() const {
  return _impl_.results_.size();
}
inline int SearchProductsResponse::results_size() const {
  return _internal_results_size();
}
inline void SearchProductsResponse::clear_results() {
  _impl_.results_.Clear();
}
inline ::oteldemo::Product* SearchProductsResponse::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:oteldemo.SearchProductsResponse.results)
  return _impl_.results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::Product >*
SearchProductsResponse::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:oteldemo.SearchProductsResponse.results)
  return &_impl_.results_;
}
inline const ::oteldemo::Product& SearchProductsResponse::_internal_results(int index) const {
  return _impl_.results_.Get(index);
}
inline const ::oteldemo::Product& SearchProductsResponse::results(int index) const {
  // @@protoc_insertion_point(field_get:oteldemo.SearchProductsResponse.results)
  return _internal_results(index);
}
inline ::oteldemo::Product* SearchProductsResponse::_internal_add_results() {
  return _impl_.results_.Add();
}
inline ::oteldemo::Product* SearchProductsResponse::add_results() {
  ::oteldemo::Product* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:oteldemo.SearchProductsResponse.results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::Product >&
SearchProductsResponse::results() const {
  // @@protoc_insertion_point(field_list:oteldemo.SearchProductsResponse.results)
  return _impl_.results_;
}

// -------------------------------------------------------------------

// GetQuoteRequest

// .oteldemo.Address address = 1;
inline bool GetQuoteRequest::_internal_has_address() const {
  return this != internal_default_instance() && _impl_.address_ != nullptr;
}
inline bool GetQuoteRequest::has_address() const {
  return _internal_has_address();
}
inline void GetQuoteRequest::clear_address() {
  if (GetArenaForAllocation() == nullptr && _impl_.address_ != nullptr) {
    delete _impl_.address_;
  }
  _impl_.address_ = nullptr;
}
inline const ::oteldemo::Address& GetQuoteRequest::_internal_address() const {
  const ::oteldemo::Address* p = _impl_.address_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::Address&>(
      ::oteldemo::_Address_default_instance_);
}
inline const ::oteldemo::Address& GetQuoteRequest::address() const {
  // @@protoc_insertion_point(field_get:oteldemo.GetQuoteRequest.address)
  return _internal_address();
}
inline void GetQuoteRequest::unsafe_arena_set_allocated_address(
    ::oteldemo::Address* address) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.address_);
  }
  _impl_.address_ = address;
  if (address) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.GetQuoteRequest.address)
}
inline ::oteldemo::Address* GetQuoteRequest::release_address() {
  
  ::oteldemo::Address* temp = _impl_.address_;
  _impl_.address_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::oteldemo::Address* GetQuoteRequest::unsafe_arena_release_address() {
  // @@protoc_insertion_point(field_release:oteldemo.GetQuoteRequest.address)
  
  ::oteldemo::Address* temp = _impl_.address_;
  _impl_.address_ = nullptr;
  return temp;
}
inline ::oteldemo::Address* GetQuoteRequest::_internal_mutable_address() {
  
  if (_impl_.address_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::Address>(GetArenaForAllocation());
    _impl_.address_ = p;
  }
  return _impl_.address_;
}
inline ::oteldemo::Address* GetQuoteRequest::mutable_address() {
  ::oteldemo::Address* _msg = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:oteldemo.GetQuoteRequest.address)
  return _msg;
}
inline void GetQuoteRequest::set_allocated_address(::oteldemo::Address* address) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.address_;
  }
  if (address) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(address);
    if (message_arena != submessage_arena) {
      address = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, address, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.address_ = address;
  // @@protoc_insertion_point(field_set_allocated:oteldemo.GetQuoteRequest.address)
}

// repeated .oteldemo.CartItem items = 2;
inline int GetQuoteRequest::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int GetQuoteRequest::items_size() const {
  return _internal_items_size();
}
inline void GetQuoteRequest::clear_items() {
  _impl_.items_.Clear();
}
inline ::oteldemo::CartItem* GetQuoteRequest::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:oteldemo.GetQuoteRequest.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::CartItem >*
GetQuoteRequest::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:oteldemo.GetQuoteRequest.items)
  return &_impl_.items_;
}
inline const ::oteldemo::CartItem& GetQuoteRequest::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::oteldemo::CartItem& GetQuoteRequest::items(int index) const {
  // @@protoc_insertion_point(field_get:oteldemo.GetQuoteRequest.items)
  return _internal_items(index);
}
inline ::oteldemo::CartItem* GetQuoteRequest::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::oteldemo::CartItem* GetQuoteRequest::add_items() {
  ::oteldemo::CartItem* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:oteldemo.GetQuoteRequest.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::CartItem >&
GetQuoteRequest::items() const {
  // @@protoc_insertion_point(field_list:oteldemo.GetQuoteRequest.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// GetQuoteResponse

// .oteldemo.Money cost_usd = 1;
inline bool GetQuoteResponse::_internal_has_cost_usd() const {
  return this != internal_default_instance() && _impl_.cost_usd_ != nullptr;
}
inline bool GetQuoteResponse::has_cost_usd() const {
  return _internal_has_cost_usd();
}
inline void GetQuoteResponse::clear_cost_usd() {
  if (GetArenaForAllocation() == nullptr && _impl_.cost_usd_ != nullptr) {
    delete _impl_.cost_usd_;
  }
  _impl_.cost_usd_ = nullptr;
}
inline const ::oteldemo::Money& GetQuoteResponse::_internal_cost_usd() const {
  const ::oteldemo::Money* p = _impl_.cost_usd_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::Money&>(
      ::oteldemo::_Money_default_instance_);
}
inline const ::oteldemo::Money& GetQuoteResponse::cost_usd() const {
  // @@protoc_insertion_point(field_get:oteldemo.GetQuoteResponse.cost_usd)
  return _internal_cost_usd();
}
inline void GetQuoteResponse::unsafe_arena_set_allocated_cost_usd(
    ::oteldemo::Money* cost_usd) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cost_usd_);
  }
  _impl_.cost_usd_ = cost_usd;
  if (cost_usd) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.GetQuoteResponse.cost_usd)
}
inline ::oteldemo::Money* GetQuoteResponse::release_cost_usd() {
  
  ::oteldemo::Money* temp = _impl_.cost_usd_;
  _impl_.cost_usd_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::oteldemo::Money* GetQuoteResponse::unsafe_arena_release_cost_usd() {
  // @@protoc_insertion_point(field_release:oteldemo.GetQuoteResponse.cost_usd)
  
  ::oteldemo::Money* temp = _impl_.cost_usd_;
  _impl_.cost_usd_ = nullptr;
  return temp;
}
inline ::oteldemo::Money* GetQuoteResponse::_internal_mutable_cost_usd() {
  
  if (_impl_.cost_usd_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::Money>(GetArenaForAllocation());
    _impl_.cost_usd_ = p;
  }
  return _impl_.cost_usd_;
}
inline ::oteldemo::Money* GetQuoteResponse::mutable_cost_usd() {
  ::oteldemo::Money* _msg = _internal_mutable_cost_usd();
  // @@protoc_insertion_point(field_mutable:oteldemo.GetQuoteResponse.cost_usd)
  return _msg;
}
inline void GetQuoteResponse::set_allocated_cost_usd(::oteldemo::Money* cost_usd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cost_usd_;
  }
  if (cost_usd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cost_usd);
    if (message_arena != submessage_arena) {
      cost_usd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cost_usd, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cost_usd_ = cost_usd;
  // @@protoc_insertion_point(field_set_allocated:oteldemo.GetQuoteResponse.cost_usd)
}

// -------------------------------------------------------------------

// ShipOrderRequest

// .oteldemo.Address address = 1;
inline bool ShipOrderRequest::_internal_has_address() const {
  return this != internal_default_instance() && _impl_.address_ != nullptr;
}
inline bool ShipOrderRequest::has_address() const {
  return _internal_has_address();
}
inline void ShipOrderRequest::clear_address() {
  if (GetArenaForAllocation() == nullptr && _impl_.address_ != nullptr) {
    delete _impl_.address_;
  }
  _impl_.address_ = nullptr;
}
inline const ::oteldemo::Address& ShipOrderRequest::_internal_address() const {
  const ::oteldemo::Address* p = _impl_.address_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::Address&>(
      ::oteldemo::_Address_default_instance_);
}
inline const ::oteldemo::Address& ShipOrderRequest::address() const {
  // @@protoc_insertion_point(field_get:oteldemo.ShipOrderRequest.address)
  return _internal_address();
}
inline void ShipOrderRequest::unsafe_arena_set_allocated_address(
    ::oteldemo::Address* address) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.address_);
  }
  _impl_.address_ = address;
  if (address) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.ShipOrderRequest.address)
}
inline ::oteldemo::Address* ShipOrderRequest::release_address() {
  
  ::oteldemo::Address* temp = _impl_.address_;
  _impl_.address_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::oteldemo::Address* ShipOrderRequest::unsafe_arena_release_address() {
  // @@protoc_insertion_point(field_release:oteldemo.ShipOrderRequest.address)
  
  ::oteldemo::Address* temp = _impl_.address_;
  _impl_.address_ = nullptr;
  return temp;
}
inline ::oteldemo::Address* ShipOrderRequest::_internal_mutable_address() {
  
  if (_impl_.address_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::Address>(GetArenaForAllocation());
    _impl_.address_ = p;
  }
  return _impl_.address_;
}
inline ::oteldemo::Address* ShipOrderRequest::mutable_address() {
  ::oteldemo::Address* _msg = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:oteldemo.ShipOrderRequest.address)
  return _msg;
}
inline void ShipOrderRequest::set_allocated_address(::oteldemo::Address* address) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.address_;
  }
  if (address) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(address);
    if (message_arena != submessage_arena) {
      address = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, address, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.address_ = address;
  // @@protoc_insertion_point(field_set_allocated:oteldemo.ShipOrderRequest.address)
}

// repeated .oteldemo.CartItem items = 2;
inline int ShipOrderRequest::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int ShipOrderRequest::items_size() const {
  return _internal_items_size();
}
inline void ShipOrderRequest::clear_items() {
  _impl_.items_.Clear();
}
inline ::oteldemo::CartItem* ShipOrderRequest::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:oteldemo.ShipOrderRequest.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::CartItem >*
ShipOrderRequest::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:oteldemo.ShipOrderRequest.items)
  return &_impl_.items_;
}
inline const ::oteldemo::CartItem& ShipOrderRequest::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::oteldemo::CartItem& ShipOrderRequest::items(int index) const {
  // @@protoc_insertion_point(field_get:oteldemo.ShipOrderRequest.items)
  return _internal_items(index);
}
inline ::oteldemo::CartItem* ShipOrderRequest::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::oteldemo::CartItem* ShipOrderRequest::add_items() {
  ::oteldemo::CartItem* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:oteldemo.ShipOrderRequest.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::CartItem >&
ShipOrderRequest::items() const {
  // @@protoc_insertion_point(field_list:oteldemo.ShipOrderRequest.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// ShipOrderResponse

// string tracking_id = 1;
inline void ShipOrderResponse::clear_tracking_id() {
  _impl_.tracking_id_.ClearToEmpty();
}
inline const std::string& ShipOrderResponse::tracking_id() const {
  // @@protoc_insertion_point(field_get:oteldemo.ShipOrderResponse.tracking_id)
  return _internal_tracking_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShipOrderResponse::set_tracking_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tracking_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.ShipOrderResponse.tracking_id)
}
inline std::string* ShipOrderResponse::mutable_tracking_id() {
  std::string* _s = _internal_mutable_tracking_id();
  // @@protoc_insertion_point(field_mutable:oteldemo.ShipOrderResponse.tracking_id)
  return _s;
}
inline const std::string& ShipOrderResponse::_internal_tracking_id() const {
  return _impl_.tracking_id_.Get();
}
inline void ShipOrderResponse::_internal_set_tracking_id(const std::string& value) {
  
  _impl_.tracking_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ShipOrderResponse::_internal_mutable_tracking_id() {
  
  return _impl_.tracking_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ShipOrderResponse::release_tracking_id() {
  // @@protoc_insertion_point(field_release:oteldemo.ShipOrderResponse.tracking_id)
  return _impl_.tracking_id_.Release();
}
inline void ShipOrderResponse::set_allocated_tracking_id(std::string* tracking_id) {
  if (tracking_id != nullptr) {
    
  } else {
    
  }
  _impl_.tracking_id_.SetAllocated(tracking_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tracking_id_.IsDefault()) {
    _impl_.tracking_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.ShipOrderResponse.tracking_id)
}

// -------------------------------------------------------------------

// Address

// string street_address = 1;
inline void Address::clear_street_address() {
  _impl_.street_address_.ClearToEmpty();
}
inline const std::string& Address::street_address() const {
  // @@protoc_insertion_point(field_get:oteldemo.Address.street_address)
  return _internal_street_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Address::set_street_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.street_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.Address.street_address)
}
inline std::string* Address::mutable_street_address() {
  std::string* _s = _internal_mutable_street_address();
  // @@protoc_insertion_point(field_mutable:oteldemo.Address.street_address)
  return _s;
}
inline const std::string& Address::_internal_street_address() const {
  return _impl_.street_address_.Get();
}
inline void Address::_internal_set_street_address(const std::string& value) {
  
  _impl_.street_address_.Set(value, GetArenaForAllocation());
}
inline std::string* Address::_internal_mutable_street_address() {
  
  return _impl_.street_address_.Mutable(GetArenaForAllocation());
}
inline std::string* Address::release_street_address() {
  // @@protoc_insertion_point(field_release:oteldemo.Address.street_address)
  return _impl_.street_address_.Release();
}
inline void Address::set_allocated_street_address(std::string* street_address) {
  if (street_address != nullptr) {
    
  } else {
    
  }
  _impl_.street_address_.SetAllocated(street_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.street_address_.IsDefault()) {
    _impl_.street_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.Address.street_address)
}

// string city = 2;
inline void Address::clear_city() {
  _impl_.city_.ClearToEmpty();
}
inline const std::string& Address::city() const {
  // @@protoc_insertion_point(field_get:oteldemo.Address.city)
  return _internal_city();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Address::set_city(ArgT0&& arg0, ArgT... args) {
 
 _impl_.city_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.Address.city)
}
inline std::string* Address::mutable_city() {
  std::string* _s = _internal_mutable_city();
  // @@protoc_insertion_point(field_mutable:oteldemo.Address.city)
  return _s;
}
inline const std::string& Address::_internal_city() const {
  return _impl_.city_.Get();
}
inline void Address::_internal_set_city(const std::string& value) {
  
  _impl_.city_.Set(value, GetArenaForAllocation());
}
inline std::string* Address::_internal_mutable_city() {
  
  return _impl_.city_.Mutable(GetArenaForAllocation());
}
inline std::string* Address::release_city() {
  // @@protoc_insertion_point(field_release:oteldemo.Address.city)
  return _impl_.city_.Release();
}
inline void Address::set_allocated_city(std::string* city) {
  if (city != nullptr) {
    
  } else {
    
  }
  _impl_.city_.SetAllocated(city, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.city_.IsDefault()) {
    _impl_.city_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.Address.city)
}

// string state = 3;
inline void Address::clear_state() {
  _impl_.state_.ClearToEmpty();
}
inline const std::string& Address::state() const {
  // @@protoc_insertion_point(field_get:oteldemo.Address.state)
  return _internal_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Address::set_state(ArgT0&& arg0, ArgT... args) {
 
 _impl_.state_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.Address.state)
}
inline std::string* Address::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:oteldemo.Address.state)
  return _s;
}
inline const std::string& Address::_internal_state() const {
  return _impl_.state_.Get();
}
inline void Address::_internal_set_state(const std::string& value) {
  
  _impl_.state_.Set(value, GetArenaForAllocation());
}
inline std::string* Address::_internal_mutable_state() {
  
  return _impl_.state_.Mutable(GetArenaForAllocation());
}
inline std::string* Address::release_state() {
  // @@protoc_insertion_point(field_release:oteldemo.Address.state)
  return _impl_.state_.Release();
}
inline void Address::set_allocated_state(std::string* state) {
  if (state != nullptr) {
    
  } else {
    
  }
  _impl_.state_.SetAllocated(state, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.state_.IsDefault()) {
    _impl_.state_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.Address.state)
}

// string country = 4;
inline void Address::clear_country() {
  _impl_.country_.ClearToEmpty();
}
inline const std::string& Address::country() const {
  // @@protoc_insertion_point(field_get:oteldemo.Address.country)
  return _internal_country();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Address::set_country(ArgT0&& arg0, ArgT... args) {
 
 _impl_.country_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.Address.country)
}
inline std::string* Address::mutable_country() {
  std::string* _s = _internal_mutable_country();
  // @@protoc_insertion_point(field_mutable:oteldemo.Address.country)
  return _s;
}
inline const std::string& Address::_internal_country() const {
  return _impl_.country_.Get();
}
inline void Address::_internal_set_country(const std::string& value) {
  
  _impl_.country_.Set(value, GetArenaForAllocation());
}
inline std::string* Address::_internal_mutable_country() {
  
  return _impl_.country_.Mutable(GetArenaForAllocation());
}
inline std::string* Address::release_country() {
  // @@protoc_insertion_point(field_release:oteldemo.Address.country)
  return _impl_.country_.Release();
}
inline void Address::set_allocated_country(std::string* country) {
  if (country != nullptr) {
    
  } else {
    
  }
  _impl_.country_.SetAllocated(country, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.country_.IsDefault()) {
    _impl_.country_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.Address.country)
}

// string zip_code = 5;
inline void Address::clear_zip_code() {
  _impl_.zip_code_.ClearToEmpty();
}
inline const std::string& Address::zip_code() const {
  // @@protoc_insertion_point(field_get:oteldemo.Address.zip_code)
  return _internal_zip_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Address::set_zip_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.zip_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.Address.zip_code)
}
inline std::string* Address::mutable_zip_code() {
  std::string* _s = _internal_mutable_zip_code();
  // @@protoc_insertion_point(field_mutable:oteldemo.Address.zip_code)
  return _s;
}
inline const std::string& Address::_internal_zip_code() const {
  return _impl_.zip_code_.Get();
}
inline void Address::_internal_set_zip_code(const std::string& value) {
  
  _impl_.zip_code_.Set(value, GetArenaForAllocation());
}
inline std::string* Address::_internal_mutable_zip_code() {
  
  return _impl_.zip_code_.Mutable(GetArenaForAllocation());
}
inline std::string* Address::release_zip_code() {
  // @@protoc_insertion_point(field_release:oteldemo.Address.zip_code)
  return _impl_.zip_code_.Release();
}
inline void Address::set_allocated_zip_code(std::string* zip_code) {
  if (zip_code != nullptr) {
    
  } else {
    
  }
  _impl_.zip_code_.SetAllocated(zip_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.zip_code_.IsDefault()) {
    _impl_.zip_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.Address.zip_code)
}

// -------------------------------------------------------------------

// Money

// string currency_code = 1;
inline void Money::clear_currency_code() {
  _impl_.currency_code_.ClearToEmpty();
}
inline const std::string& Money::currency_code() const {
  // @@protoc_insertion_point(field_get:oteldemo.Money.currency_code)
  return _internal_currency_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Money::set_currency_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.currency_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.Money.currency_code)
}
inline std::string* Money::mutable_currency_code() {
  std::string* _s = _internal_mutable_currency_code();
  // @@protoc_insertion_point(field_mutable:oteldemo.Money.currency_code)
  return _s;
}
inline const std::string& Money::_internal_currency_code() const {
  return _impl_.currency_code_.Get();
}
inline void Money::_internal_set_currency_code(const std::string& value) {
  
  _impl_.currency_code_.Set(value, GetArenaForAllocation());
}
inline std::string* Money::_internal_mutable_currency_code() {
  
  return _impl_.currency_code_.Mutable(GetArenaForAllocation());
}
inline std::string* Money::release_currency_code() {
  // @@protoc_insertion_point(field_release:oteldemo.Money.currency_code)
  return _impl_.currency_code_.Release();
}
inline void Money::set_allocated_currency_code(std::string* currency_code) {
  if (currency_code != nullptr) {
    
  } else {
    
  }
  _impl_.currency_code_.SetAllocated(currency_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.currency_code_.IsDefault()) {
    _impl_.currency_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.Money.currency_code)
}

// int64 units = 2;
inline void Money::clear_units() {
  _impl_.units_ = int64_t{0};
}
inline int64_t Money::_internal_units() const {
  return _impl_.units_;
}
inline int64_t Money::units() const {
  // @@protoc_insertion_point(field_get:oteldemo.Money.units)
  return _internal_units();
}
inline void Money::_internal_set_units(int64_t value) {
  
  _impl_.units_ = value;
}
inline void Money::set_units(int64_t value) {
  _internal_set_units(value);
  // @@protoc_insertion_point(field_set:oteldemo.Money.units)
}

// int32 nanos = 3;
inline void Money::clear_nanos() {
  _impl_.nanos_ = 0;
}
inline int32_t Money::_internal_nanos() const {
  return _impl_.nanos_;
}
inline int32_t Money::nanos() const {
  // @@protoc_insertion_point(field_get:oteldemo.Money.nanos)
  return _internal_nanos();
}
inline void Money::_internal_set_nanos(int32_t value) {
  
  _impl_.nanos_ = value;
}
inline void Money::set_nanos(int32_t value) {
  _internal_set_nanos(value);
  // @@protoc_insertion_point(field_set:oteldemo.Money.nanos)
}

// -------------------------------------------------------------------

// GetSupportedCurrenciesResponse

// repeated string currency_codes = 1;
inline int GetSupportedCurrenciesResponse::_internal_currency_codes_size() const {
  return _impl_.currency_codes_.size();
}
inline int GetSupportedCurrenciesResponse::currency_codes_size() const {
  return _internal_currency_codes_size();
}
inline void GetSupportedCurrenciesResponse::clear_currency_codes() {
  _impl_.currency_codes_.Clear();
}
inline std::string* GetSupportedCurrenciesResponse::add_currency_codes() {
  std::string* _s = _internal_add_currency_codes();
  // @@protoc_insertion_point(field_add_mutable:oteldemo.GetSupportedCurrenciesResponse.currency_codes)
  return _s;
}
inline const std::string& GetSupportedCurrenciesResponse::_internal_currency_codes(int index) const {
  return _impl_.currency_codes_.Get(index);
}
inline const std::string& GetSupportedCurrenciesResponse::currency_codes(int index) const {
  // @@protoc_insertion_point(field_get:oteldemo.GetSupportedCurrenciesResponse.currency_codes)
  return _internal_currency_codes(index);
}
inline std::string* GetSupportedCurrenciesResponse::mutable_currency_codes(int index) {
  // @@protoc_insertion_point(field_mutable:oteldemo.GetSupportedCurrenciesResponse.currency_codes)
  return _impl_.currency_codes_.Mutable(index);
}
inline void GetSupportedCurrenciesResponse::set_currency_codes(int index, const std::string& value) {
  _impl_.currency_codes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:oteldemo.GetSupportedCurrenciesResponse.currency_codes)
}
inline void GetSupportedCurrenciesResponse::set_currency_codes(int index, std::string&& value) {
  _impl_.currency_codes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:oteldemo.GetSupportedCurrenciesResponse.currency_codes)
}
inline void GetSupportedCurrenciesResponse::set_currency_codes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.currency_codes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:oteldemo.GetSupportedCurrenciesResponse.currency_codes)
}
inline void GetSupportedCurrenciesResponse::set_currency_codes(int index, const char* value, size_t size) {
  _impl_.currency_codes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:oteldemo.GetSupportedCurrenciesResponse.currency_codes)
}
inline std::string* GetSupportedCurrenciesResponse::_internal_add_currency_codes() {
  return _impl_.currency_codes_.Add();
}
inline void GetSupportedCurrenciesResponse::add_currency_codes(const std::string& value) {
  _impl_.currency_codes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:oteldemo.GetSupportedCurrenciesResponse.currency_codes)
}
inline void GetSupportedCurrenciesResponse::add_currency_codes(std::string&& value) {
  _impl_.currency_codes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:oteldemo.GetSupportedCurrenciesResponse.currency_codes)
}
inline void GetSupportedCurrenciesResponse::add_currency_codes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.currency_codes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:oteldemo.GetSupportedCurrenciesResponse.currency_codes)
}
inline void GetSupportedCurrenciesResponse::add_currency_codes(const char* value, size_t size) {
  _impl_.currency_codes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:oteldemo.GetSupportedCurrenciesResponse.currency_codes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetSupportedCurrenciesResponse::currency_codes() const {
  // @@protoc_insertion_point(field_list:oteldemo.GetSupportedCurrenciesResponse.currency_codes)
  return _impl_.currency_codes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetSupportedCurrenciesResponse::mutable_currency_codes() {
  // @@protoc_insertion_point(field_mutable_list:oteldemo.GetSupportedCurrenciesResponse.currency_codes)
  return &_impl_.currency_codes_;
}

// -------------------------------------------------------------------

// CurrencyConversionRequest

// .oteldemo.Money from = 1;
inline bool CurrencyConversionRequest::_internal_has_from() const {
  return this != internal_default_instance() && _impl_.from_ != nullptr;
}
inline bool CurrencyConversionRequest::has_from() const {
  return _internal_has_from();
}
inline void CurrencyConversionRequest::clear_from() {
  if (GetArenaForAllocation() == nullptr && _impl_.from_ != nullptr) {
    delete _impl_.from_;
  }
  _impl_.from_ = nullptr;
}
inline const ::oteldemo::Money& CurrencyConversionRequest::_internal_from() const {
  const ::oteldemo::Money* p = _impl_.from_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::Money&>(
      ::oteldemo::_Money_default_instance_);
}
inline const ::oteldemo::Money& CurrencyConversionRequest::from() const {
  // @@protoc_insertion_point(field_get:oteldemo.CurrencyConversionRequest.from)
  return _internal_from();
}
inline void CurrencyConversionRequest::unsafe_arena_set_allocated_from(
    ::oteldemo::Money* from) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.from_);
  }
  _impl_.from_ = from;
  if (from) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.CurrencyConversionRequest.from)
}
inline ::oteldemo::Money* CurrencyConversionRequest::release_from() {
  
  ::oteldemo::Money* temp = _impl_.from_;
  _impl_.from_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::oteldemo::Money* CurrencyConversionRequest::unsafe_arena_release_from() {
  // @@protoc_insertion_point(field_release:oteldemo.CurrencyConversionRequest.from)
  
  ::oteldemo::Money* temp = _impl_.from_;
  _impl_.from_ = nullptr;
  return temp;
}
inline ::oteldemo::Money* CurrencyConversionRequest::_internal_mutable_from() {
  
  if (_impl_.from_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::Money>(GetArenaForAllocation());
    _impl_.from_ = p;
  }
  return _impl_.from_;
}
inline ::oteldemo::Money* CurrencyConversionRequest::mutable_from() {
  ::oteldemo::Money* _msg = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:oteldemo.CurrencyConversionRequest.from)
  return _msg;
}
inline void CurrencyConversionRequest::set_allocated_from(::oteldemo::Money* from) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.from_;
  }
  if (from) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(from);
    if (message_arena != submessage_arena) {
      from = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, from, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.from_ = from;
  // @@protoc_insertion_point(field_set_allocated:oteldemo.CurrencyConversionRequest.from)
}

// string to_code = 2;
inline void CurrencyConversionRequest::clear_to_code() {
  _impl_.to_code_.ClearToEmpty();
}
inline const std::string& CurrencyConversionRequest::to_code() const {
  // @@protoc_insertion_point(field_get:oteldemo.CurrencyConversionRequest.to_code)
  return _internal_to_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CurrencyConversionRequest::set_to_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.to_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.CurrencyConversionRequest.to_code)
}
inline std::string* CurrencyConversionRequest::mutable_to_code() {
  std::string* _s = _internal_mutable_to_code();
  // @@protoc_insertion_point(field_mutable:oteldemo.CurrencyConversionRequest.to_code)
  return _s;
}
inline const std::string& CurrencyConversionRequest::_internal_to_code() const {
  return _impl_.to_code_.Get();
}
inline void CurrencyConversionRequest::_internal_set_to_code(const std::string& value) {
  
  _impl_.to_code_.Set(value, GetArenaForAllocation());
}
inline std::string* CurrencyConversionRequest::_internal_mutable_to_code() {
  
  return _impl_.to_code_.Mutable(GetArenaForAllocation());
}
inline std::string* CurrencyConversionRequest::release_to_code() {
  // @@protoc_insertion_point(field_release:oteldemo.CurrencyConversionRequest.to_code)
  return _impl_.to_code_.Release();
}
inline void CurrencyConversionRequest::set_allocated_to_code(std::string* to_code) {
  if (to_code != nullptr) {
    
  } else {
    
  }
  _impl_.to_code_.SetAllocated(to_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.to_code_.IsDefault()) {
    _impl_.to_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.CurrencyConversionRequest.to_code)
}

// -------------------------------------------------------------------

// CreditCardInfo

// string credit_card_number = 1;
inline void CreditCardInfo::clear_credit_card_number() {
  _impl_.credit_card_number_.ClearToEmpty();
}
inline const std::string& CreditCardInfo::credit_card_number() const {
  // @@protoc_insertion_point(field_get:oteldemo.CreditCardInfo.credit_card_number)
  return _internal_credit_card_number();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreditCardInfo::set_credit_card_number(ArgT0&& arg0, ArgT... args) {
 
 _impl_.credit_card_number_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.CreditCardInfo.credit_card_number)
}
inline std::string* CreditCardInfo::mutable_credit_card_number() {
  std::string* _s = _internal_mutable_credit_card_number();
  // @@protoc_insertion_point(field_mutable:oteldemo.CreditCardInfo.credit_card_number)
  return _s;
}
inline const std::string& CreditCardInfo::_internal_credit_card_number() const {
  return _impl_.credit_card_number_.Get();
}
inline void CreditCardInfo::_internal_set_credit_card_number(const std::string& value) {
  
  _impl_.credit_card_number_.Set(value, GetArenaForAllocation());
}
inline std::string* CreditCardInfo::_internal_mutable_credit_card_number() {
  
  return _impl_.credit_card_number_.Mutable(GetArenaForAllocation());
}
inline std::string* CreditCardInfo::release_credit_card_number() {
  // @@protoc_insertion_point(field_release:oteldemo.CreditCardInfo.credit_card_number)
  return _impl_.credit_card_number_.Release();
}
inline void CreditCardInfo::set_allocated_credit_card_number(std::string* credit_card_number) {
  if (credit_card_number != nullptr) {
    
  } else {
    
  }
  _impl_.credit_card_number_.SetAllocated(credit_card_number, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.credit_card_number_.IsDefault()) {
    _impl_.credit_card_number_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.CreditCardInfo.credit_card_number)
}

// int32 credit_card_cvv = 2;
inline void CreditCardInfo::clear_credit_card_cvv() {
  _impl_.credit_card_cvv_ = 0;
}
inline int32_t CreditCardInfo::_internal_credit_card_cvv() const {
  return _impl_.credit_card_cvv_;
}
inline int32_t CreditCardInfo::credit_card_cvv() const {
  // @@protoc_insertion_point(field_get:oteldemo.CreditCardInfo.credit_card_cvv)
  return _internal_credit_card_cvv();
}
inline void CreditCardInfo::_internal_set_credit_card_cvv(int32_t value) {
  
  _impl_.credit_card_cvv_ = value;
}
inline void CreditCardInfo::set_credit_card_cvv(int32_t value) {
  _internal_set_credit_card_cvv(value);
  // @@protoc_insertion_point(field_set:oteldemo.CreditCardInfo.credit_card_cvv)
}

// int32 credit_card_expiration_year = 3;
inline void CreditCardInfo::clear_credit_card_expiration_year() {
  _impl_.credit_card_expiration_year_ = 0;
}
inline int32_t CreditCardInfo::_internal_credit_card_expiration_year() const {
  return _impl_.credit_card_expiration_year_;
}
inline int32_t CreditCardInfo::credit_card_expiration_year() const {
  // @@protoc_insertion_point(field_get:oteldemo.CreditCardInfo.credit_card_expiration_year)
  return _internal_credit_card_expiration_year();
}
inline void CreditCardInfo::_internal_set_credit_card_expiration_year(int32_t value) {
  
  _impl_.credit_card_expiration_year_ = value;
}
inline void CreditCardInfo::set_credit_card_expiration_year(int32_t value) {
  _internal_set_credit_card_expiration_year(value);
  // @@protoc_insertion_point(field_set:oteldemo.CreditCardInfo.credit_card_expiration_year)
}

// int32 credit_card_expiration_month = 4;
inline void CreditCardInfo::clear_credit_card_expiration_month() {
  _impl_.credit_card_expiration_month_ = 0;
}
inline int32_t CreditCardInfo::_internal_credit_card_expiration_month() const {
  return _impl_.credit_card_expiration_month_;
}
inline int32_t CreditCardInfo::credit_card_expiration_month() const {
  // @@protoc_insertion_point(field_get:oteldemo.CreditCardInfo.credit_card_expiration_month)
  return _internal_credit_card_expiration_month();
}
inline void CreditCardInfo::_internal_set_credit_card_expiration_month(int32_t value) {
  
  _impl_.credit_card_expiration_month_ = value;
}
inline void CreditCardInfo::set_credit_card_expiration_month(int32_t value) {
  _internal_set_credit_card_expiration_month(value);
  // @@protoc_insertion_point(field_set:oteldemo.CreditCardInfo.credit_card_expiration_month)
}

// -------------------------------------------------------------------

// ChargeRequest

// .oteldemo.Money amount = 1;
inline bool ChargeRequest::_internal_has_amount() const {
  return this != internal_default_instance() && _impl_.amount_ != nullptr;
}
inline bool ChargeRequest::has_amount() const {
  return _internal_has_amount();
}
inline void ChargeRequest::clear_amount() {
  if (GetArenaForAllocation() == nullptr && _impl_.amount_ != nullptr) {
    delete _impl_.amount_;
  }
  _impl_.amount_ = nullptr;
}
inline const ::oteldemo::Money& ChargeRequest::_internal_amount() const {
  const ::oteldemo::Money* p = _impl_.amount_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::Money&>(
      ::oteldemo::_Money_default_instance_);
}
inline const ::oteldemo::Money& ChargeRequest::amount() const {
  // @@protoc_insertion_point(field_get:oteldemo.ChargeRequest.amount)
  return _internal_amount();
}
inline void ChargeRequest::unsafe_arena_set_allocated_amount(
    ::oteldemo::Money* amount) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_);
  }
  _impl_.amount_ = amount;
  if (amount) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.ChargeRequest.amount)
}
inline ::oteldemo::Money* ChargeRequest::release_amount() {
  
  ::oteldemo::Money* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::oteldemo::Money* ChargeRequest::unsafe_arena_release_amount() {
  // @@protoc_insertion_point(field_release:oteldemo.ChargeRequest.amount)
  
  ::oteldemo::Money* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
  return temp;
}
inline ::oteldemo::Money* ChargeRequest::_internal_mutable_amount() {
  
  if (_impl_.amount_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::Money>(GetArenaForAllocation());
    _impl_.amount_ = p;
  }
  return _impl_.amount_;
}
inline ::oteldemo::Money* ChargeRequest::mutable_amount() {
  ::oteldemo::Money* _msg = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:oteldemo.ChargeRequest.amount)
  return _msg;
}
inline void ChargeRequest::set_allocated_amount(::oteldemo::Money* amount) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.amount_;
  }
  if (amount) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(amount);
    if (message_arena != submessage_arena) {
      amount = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amount, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.amount_ = amount;
  // @@protoc_insertion_point(field_set_allocated:oteldemo.ChargeRequest.amount)
}

// .oteldemo.CreditCardInfo credit_card = 2;
inline bool ChargeRequest::_internal_has_credit_card() const {
  return this != internal_default_instance() && _impl_.credit_card_ != nullptr;
}
inline bool ChargeRequest::has_credit_card() const {
  return _internal_has_credit_card();
}
inline void ChargeRequest::clear_credit_card() {
  if (GetArenaForAllocation() == nullptr && _impl_.credit_card_ != nullptr) {
    delete _impl_.credit_card_;
  }
  _impl_.credit_card_ = nullptr;
}
inline const ::oteldemo::CreditCardInfo& ChargeRequest::_internal_credit_card() const {
  const ::oteldemo::CreditCardInfo* p = _impl_.credit_card_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::CreditCardInfo&>(
      ::oteldemo::_CreditCardInfo_default_instance_);
}
inline const ::oteldemo::CreditCardInfo& ChargeRequest::credit_card() const {
  // @@protoc_insertion_point(field_get:oteldemo.ChargeRequest.credit_card)
  return _internal_credit_card();
}
inline void ChargeRequest::unsafe_arena_set_allocated_credit_card(
    ::oteldemo::CreditCardInfo* credit_card) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.credit_card_);
  }
  _impl_.credit_card_ = credit_card;
  if (credit_card) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.ChargeRequest.credit_card)
}
inline ::oteldemo::CreditCardInfo* ChargeRequest::release_credit_card() {
  
  ::oteldemo::CreditCardInfo* temp = _impl_.credit_card_;
  _impl_.credit_card_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::oteldemo::CreditCardInfo* ChargeRequest::unsafe_arena_release_credit_card() {
  // @@protoc_insertion_point(field_release:oteldemo.ChargeRequest.credit_card)
  
  ::oteldemo::CreditCardInfo* temp = _impl_.credit_card_;
  _impl_.credit_card_ = nullptr;
  return temp;
}
inline ::oteldemo::CreditCardInfo* ChargeRequest::_internal_mutable_credit_card() {
  
  if (_impl_.credit_card_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::CreditCardInfo>(GetArenaForAllocation());
    _impl_.credit_card_ = p;
  }
  return _impl_.credit_card_;
}
inline ::oteldemo::CreditCardInfo* ChargeRequest::mutable_credit_card() {
  ::oteldemo::CreditCardInfo* _msg = _internal_mutable_credit_card();
  // @@protoc_insertion_point(field_mutable:oteldemo.ChargeRequest.credit_card)
  return _msg;
}
inline void ChargeRequest::set_allocated_credit_card(::oteldemo::CreditCardInfo* credit_card) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.credit_card_;
  }
  if (credit_card) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(credit_card);
    if (message_arena != submessage_arena) {
      credit_card = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, credit_card, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.credit_card_ = credit_card;
  // @@protoc_insertion_point(field_set_allocated:oteldemo.ChargeRequest.credit_card)
}

// -------------------------------------------------------------------

// ChargeResponse

// string transaction_id = 1;
inline void ChargeResponse::clear_transaction_id() {
  _impl_.transaction_id_.ClearToEmpty();
}
inline const std::string& ChargeResponse::transaction_id() const {
  // @@protoc_insertion_point(field_get:oteldemo.ChargeResponse.transaction_id)
  return _internal_transaction_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChargeResponse::set_transaction_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.transaction_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.ChargeResponse.transaction_id)
}
inline std::string* ChargeResponse::mutable_transaction_id() {
  std::string* _s = _internal_mutable_transaction_id();
  // @@protoc_insertion_point(field_mutable:oteldemo.ChargeResponse.transaction_id)
  return _s;
}
inline const std::string& ChargeResponse::_internal_transaction_id() const {
  return _impl_.transaction_id_.Get();
}
inline void ChargeResponse::_internal_set_transaction_id(const std::string& value) {
  
  _impl_.transaction_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChargeResponse::_internal_mutable_transaction_id() {
  
  return _impl_.transaction_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ChargeResponse::release_transaction_id() {
  // @@protoc_insertion_point(field_release:oteldemo.ChargeResponse.transaction_id)
  return _impl_.transaction_id_.Release();
}
inline void ChargeResponse::set_allocated_transaction_id(std::string* transaction_id) {
  if (transaction_id != nullptr) {
    
  } else {
    
  }
  _impl_.transaction_id_.SetAllocated(transaction_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.transaction_id_.IsDefault()) {
    _impl_.transaction_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.ChargeResponse.transaction_id)
}

// -------------------------------------------------------------------

// OrderItem

// .oteldemo.CartItem item = 1;
inline bool OrderItem::_internal_has_item() const {
  return this != internal_default_instance() && _impl_.item_ != nullptr;
}
inline bool OrderItem::has_item() const {
  return _internal_has_item();
}
inline void OrderItem::clear_item() {
  if (GetArenaForAllocation() == nullptr && _impl_.item_ != nullptr) {
    delete _impl_.item_;
  }
  _impl_.item_ = nullptr;
}
inline const ::oteldemo::CartItem& OrderItem::_internal_item() const {
  const ::oteldemo::CartItem* p = _impl_.item_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::CartItem&>(
      ::oteldemo::_CartItem_default_instance_);
}
inline const ::oteldemo::CartItem& OrderItem::item() const {
  // @@protoc_insertion_point(field_get:oteldemo.OrderItem.item)
  return _internal_item();
}
inline void OrderItem::unsafe_arena_set_allocated_item(
    ::oteldemo::CartItem* item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.item_);
  }
  _impl_.item_ = item;
  if (item) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.OrderItem.item)
}
inline ::oteldemo::CartItem* OrderItem::release_item() {
  
  ::oteldemo::CartItem* temp = _impl_.item_;
  _impl_.item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::oteldemo::CartItem* OrderItem::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_release:oteldemo.OrderItem.item)
  
  ::oteldemo::CartItem* temp = _impl_.item_;
  _impl_.item_ = nullptr;
  return temp;
}
inline ::oteldemo::CartItem* OrderItem::_internal_mutable_item() {
  
  if (_impl_.item_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::CartItem>(GetArenaForAllocation());
    _impl_.item_ = p;
  }
  return _impl_.item_;
}
inline ::oteldemo::CartItem* OrderItem::mutable_item() {
  ::oteldemo::CartItem* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:oteldemo.OrderItem.item)
  return _msg;
}
inline void OrderItem::set_allocated_item(::oteldemo::CartItem* item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.item_;
  }
  if (item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(item);
    if (message_arena != submessage_arena) {
      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.item_ = item;
  // @@protoc_insertion_point(field_set_allocated:oteldemo.OrderItem.item)
}

// .oteldemo.Money cost = 2;
inline bool OrderItem::_internal_has_cost() const {
  return this != internal_default_instance() && _impl_.cost_ != nullptr;
}
inline bool OrderItem::has_cost() const {
  return _internal_has_cost();
}
inline void OrderItem::clear_cost() {
  if (GetArenaForAllocation() == nullptr && _impl_.cost_ != nullptr) {
    delete _impl_.cost_;
  }
  _impl_.cost_ = nullptr;
}
inline const ::oteldemo::Money& OrderItem::_internal_cost() const {
  const ::oteldemo::Money* p = _impl_.cost_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::Money&>(
      ::oteldemo::_Money_default_instance_);
}
inline const ::oteldemo::Money& OrderItem::cost() const {
  // @@protoc_insertion_point(field_get:oteldemo.OrderItem.cost)
  return _internal_cost();
}
inline void OrderItem::unsafe_arena_set_allocated_cost(
    ::oteldemo::Money* cost) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cost_);
  }
  _impl_.cost_ = cost;
  if (cost) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.OrderItem.cost)
}
inline ::oteldemo::Money* OrderItem::release_cost() {
  
  ::oteldemo::Money* temp = _impl_.cost_;
  _impl_.cost_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::oteldemo::Money* OrderItem::unsafe_arena_release_cost() {
  // @@protoc_insertion_point(field_release:oteldemo.OrderItem.cost)
  
  ::oteldemo::Money* temp = _impl_.cost_;
  _impl_.cost_ = nullptr;
  return temp;
}
inline ::oteldemo::Money* OrderItem::_internal_mutable_cost() {
  
  if (_impl_.cost_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::Money>(GetArenaForAllocation());
    _impl_.cost_ = p;
  }
  return _impl_.cost_;
}
inline ::oteldemo::Money* OrderItem::mutable_cost() {
  ::oteldemo::Money* _msg = _internal_mutable_cost();
  // @@protoc_insertion_point(field_mutable:oteldemo.OrderItem.cost)
  return _msg;
}
inline void OrderItem::set_allocated_cost(::oteldemo::Money* cost) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cost_;
  }
  if (cost) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cost);
    if (message_arena != submessage_arena) {
      cost = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cost, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cost_ = cost;
  // @@protoc_insertion_point(field_set_allocated:oteldemo.OrderItem.cost)
}

// -------------------------------------------------------------------

// OrderResult

// string order_id = 1;
inline void OrderResult::clear_order_id() {
  _impl_.order_id_.ClearToEmpty();
}
inline const std::string& OrderResult::order_id() const {
  // @@protoc_insertion_point(field_get:oteldemo.OrderResult.order_id)
  return _internal_order_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderResult::set_order_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.order_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.OrderResult.order_id)
}
inline std::string* OrderResult::mutable_order_id() {
  std::string* _s = _internal_mutable_order_id();
  // @@protoc_insertion_point(field_mutable:oteldemo.OrderResult.order_id)
  return _s;
}
inline const std::string& OrderResult::_internal_order_id() const {
  return _impl_.order_id_.Get();
}
inline void OrderResult::_internal_set_order_id(const std::string& value) {
  
  _impl_.order_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderResult::_internal_mutable_order_id() {
  
  return _impl_.order_id_.Mutable(GetArenaForAllocation());
}
inline std::string* OrderResult::release_order_id() {
  // @@protoc_insertion_point(field_release:oteldemo.OrderResult.order_id)
  return _impl_.order_id_.Release();
}
inline void OrderResult::set_allocated_order_id(std::string* order_id) {
  if (order_id != nullptr) {
    
  } else {
    
  }
  _impl_.order_id_.SetAllocated(order_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.order_id_.IsDefault()) {
    _impl_.order_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.OrderResult.order_id)
}

// string shipping_tracking_id = 2;
inline void OrderResult::clear_shipping_tracking_id() {
  _impl_.shipping_tracking_id_.ClearToEmpty();
}
inline const std::string& OrderResult::shipping_tracking_id() const {
  // @@protoc_insertion_point(field_get:oteldemo.OrderResult.shipping_tracking_id)
  return _internal_shipping_tracking_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderResult::set_shipping_tracking_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.shipping_tracking_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.OrderResult.shipping_tracking_id)
}
inline std::string* OrderResult::mutable_shipping_tracking_id() {
  std::string* _s = _internal_mutable_shipping_tracking_id();
  // @@protoc_insertion_point(field_mutable:oteldemo.OrderResult.shipping_tracking_id)
  return _s;
}
inline const std::string& OrderResult::_internal_shipping_tracking_id() const {
  return _impl_.shipping_tracking_id_.Get();
}
inline void OrderResult::_internal_set_shipping_tracking_id(const std::string& value) {
  
  _impl_.shipping_tracking_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderResult::_internal_mutable_shipping_tracking_id() {
  
  return _impl_.shipping_tracking_id_.Mutable(GetArenaForAllocation());
}
inline std::string* OrderResult::release_shipping_tracking_id() {
  // @@protoc_insertion_point(field_release:oteldemo.OrderResult.shipping_tracking_id)
  return _impl_.shipping_tracking_id_.Release();
}
inline void OrderResult::set_allocated_shipping_tracking_id(std::string* shipping_tracking_id) {
  if (shipping_tracking_id != nullptr) {
    
  } else {
    
  }
  _impl_.shipping_tracking_id_.SetAllocated(shipping_tracking_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.shipping_tracking_id_.IsDefault()) {
    _impl_.shipping_tracking_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.OrderResult.shipping_tracking_id)
}

// .oteldemo.Money shipping_cost = 3;
inline bool OrderResult::_internal_has_shipping_cost() const {
  return this != internal_default_instance() && _impl_.shipping_cost_ != nullptr;
}
inline bool OrderResult::has_shipping_cost() const {
  return _internal_has_shipping_cost();
}
inline void OrderResult::clear_shipping_cost() {
  if (GetArenaForAllocation() == nullptr && _impl_.shipping_cost_ != nullptr) {
    delete _impl_.shipping_cost_;
  }
  _impl_.shipping_cost_ = nullptr;
}
inline const ::oteldemo::Money& OrderResult::_internal_shipping_cost() const {
  const ::oteldemo::Money* p = _impl_.shipping_cost_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::Money&>(
      ::oteldemo::_Money_default_instance_);
}
inline const ::oteldemo::Money& OrderResult::shipping_cost() const {
  // @@protoc_insertion_point(field_get:oteldemo.OrderResult.shipping_cost)
  return _internal_shipping_cost();
}
inline void OrderResult::unsafe_arena_set_allocated_shipping_cost(
    ::oteldemo::Money* shipping_cost) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.shipping_cost_);
  }
  _impl_.shipping_cost_ = shipping_cost;
  if (shipping_cost) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.OrderResult.shipping_cost)
}
inline ::oteldemo::Money* OrderResult::release_shipping_cost() {
  
  ::oteldemo::Money* temp = _impl_.shipping_cost_;
  _impl_.shipping_cost_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::oteldemo::Money* OrderResult::unsafe_arena_release_shipping_cost() {
  // @@protoc_insertion_point(field_release:oteldemo.OrderResult.shipping_cost)
  
  ::oteldemo::Money* temp = _impl_.shipping_cost_;
  _impl_.shipping_cost_ = nullptr;
  return temp;
}
inline ::oteldemo::Money* OrderResult::_internal_mutable_shipping_cost() {
  
  if (_impl_.shipping_cost_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::Money>(GetArenaForAllocation());
    _impl_.shipping_cost_ = p;
  }
  return _impl_.shipping_cost_;
}
inline ::oteldemo::Money* OrderResult::mutable_shipping_cost() {
  ::oteldemo::Money* _msg = _internal_mutable_shipping_cost();
  // @@protoc_insertion_point(field_mutable:oteldemo.OrderResult.shipping_cost)
  return _msg;
}
inline void OrderResult::set_allocated_shipping_cost(::oteldemo::Money* shipping_cost) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.shipping_cost_;
  }
  if (shipping_cost) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(shipping_cost);
    if (message_arena != submessage_arena) {
      shipping_cost = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shipping_cost, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.shipping_cost_ = shipping_cost;
  // @@protoc_insertion_point(field_set_allocated:oteldemo.OrderResult.shipping_cost)
}

// .oteldemo.Address shipping_address = 4;
inline bool OrderResult::_internal_has_shipping_address() const {
  return this != internal_default_instance() && _impl_.shipping_address_ != nullptr;
}
inline bool OrderResult::has_shipping_address() const {
  return _internal_has_shipping_address();
}
inline void OrderResult::clear_shipping_address() {
  if (GetArenaForAllocation() == nullptr && _impl_.shipping_address_ != nullptr) {
    delete _impl_.shipping_address_;
  }
  _impl_.shipping_address_ = nullptr;
}
inline const ::oteldemo::Address& OrderResult::_internal_shipping_address() const {
  const ::oteldemo::Address* p = _impl_.shipping_address_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::Address&>(
      ::oteldemo::_Address_default_instance_);
}
inline const ::oteldemo::Address& OrderResult::shipping_address() const {
  // @@protoc_insertion_point(field_get:oteldemo.OrderResult.shipping_address)
  return _internal_shipping_address();
}
inline void OrderResult::unsafe_arena_set_allocated_shipping_address(
    ::oteldemo::Address* shipping_address) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.shipping_address_);
  }
  _impl_.shipping_address_ = shipping_address;
  if (shipping_address) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.OrderResult.shipping_address)
}
inline ::oteldemo::Address* OrderResult::release_shipping_address() {
  
  ::oteldemo::Address* temp = _impl_.shipping_address_;
  _impl_.shipping_address_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::oteldemo::Address* OrderResult::unsafe_arena_release_shipping_address() {
  // @@protoc_insertion_point(field_release:oteldemo.OrderResult.shipping_address)
  
  ::oteldemo::Address* temp = _impl_.shipping_address_;
  _impl_.shipping_address_ = nullptr;
  return temp;
}
inline ::oteldemo::Address* OrderResult::_internal_mutable_shipping_address() {
  
  if (_impl_.shipping_address_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::Address>(GetArenaForAllocation());
    _impl_.shipping_address_ = p;
  }
  return _impl_.shipping_address_;
}
inline ::oteldemo::Address* OrderResult::mutable_shipping_address() {
  ::oteldemo::Address* _msg = _internal_mutable_shipping_address();
  // @@protoc_insertion_point(field_mutable:oteldemo.OrderResult.shipping_address)
  return _msg;
}
inline void OrderResult::set_allocated_shipping_address(::oteldemo::Address* shipping_address) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.shipping_address_;
  }
  if (shipping_address) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(shipping_address);
    if (message_arena != submessage_arena) {
      shipping_address = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shipping_address, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.shipping_address_ = shipping_address;
  // @@protoc_insertion_point(field_set_allocated:oteldemo.OrderResult.shipping_address)
}

// repeated .oteldemo.OrderItem items = 5;
inline int OrderResult::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int OrderResult::items_size() const {
  return _internal_items_size();
}
inline void OrderResult::clear_items() {
  _impl_.items_.Clear();
}
inline ::oteldemo::OrderItem* OrderResult::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:oteldemo.OrderResult.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::OrderItem >*
OrderResult::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:oteldemo.OrderResult.items)
  return &_impl_.items_;
}
inline const ::oteldemo::OrderItem& OrderResult::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::oteldemo::OrderItem& OrderResult::items(int index) const {
  // @@protoc_insertion_point(field_get:oteldemo.OrderResult.items)
  return _internal_items(index);
}
inline ::oteldemo::OrderItem* OrderResult::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::oteldemo::OrderItem* OrderResult::add_items() {
  ::oteldemo::OrderItem* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:oteldemo.OrderResult.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::OrderItem >&
OrderResult::items() const {
  // @@protoc_insertion_point(field_list:oteldemo.OrderResult.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// SendOrderConfirmationRequest

// string email = 1;
inline void SendOrderConfirmationRequest::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& SendOrderConfirmationRequest::email() const {
  // @@protoc_insertion_point(field_get:oteldemo.SendOrderConfirmationRequest.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendOrderConfirmationRequest::set_email(ArgT0&& arg0, ArgT... args) {
 
 _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.SendOrderConfirmationRequest.email)
}
inline std::string* SendOrderConfirmationRequest::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:oteldemo.SendOrderConfirmationRequest.email)
  return _s;
}
inline const std::string& SendOrderConfirmationRequest::_internal_email() const {
  return _impl_.email_.Get();
}
inline void SendOrderConfirmationRequest::_internal_set_email(const std::string& value) {
  
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* SendOrderConfirmationRequest::_internal_mutable_email() {
  
  return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* SendOrderConfirmationRequest::release_email() {
  // @@protoc_insertion_point(field_release:oteldemo.SendOrderConfirmationRequest.email)
  return _impl_.email_.Release();
}
inline void SendOrderConfirmationRequest::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.SendOrderConfirmationRequest.email)
}

// .oteldemo.OrderResult order = 2;
inline bool SendOrderConfirmationRequest::_internal_has_order() const {
  return this != internal_default_instance() && _impl_.order_ != nullptr;
}
inline bool SendOrderConfirmationRequest::has_order() const {
  return _internal_has_order();
}
inline void SendOrderConfirmationRequest::clear_order() {
  if (GetArenaForAllocation() == nullptr && _impl_.order_ != nullptr) {
    delete _impl_.order_;
  }
  _impl_.order_ = nullptr;
}
inline const ::oteldemo::OrderResult& SendOrderConfirmationRequest::_internal_order() const {
  const ::oteldemo::OrderResult* p = _impl_.order_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::OrderResult&>(
      ::oteldemo::_OrderResult_default_instance_);
}
inline const ::oteldemo::OrderResult& SendOrderConfirmationRequest::order() const {
  // @@protoc_insertion_point(field_get:oteldemo.SendOrderConfirmationRequest.order)
  return _internal_order();
}
inline void SendOrderConfirmationRequest::unsafe_arena_set_allocated_order(
    ::oteldemo::OrderResult* order) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.order_);
  }
  _impl_.order_ = order;
  if (order) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.SendOrderConfirmationRequest.order)
}
inline ::oteldemo::OrderResult* SendOrderConfirmationRequest::release_order() {
  
  ::oteldemo::OrderResult* temp = _impl_.order_;
  _impl_.order_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::oteldemo::OrderResult* SendOrderConfirmationRequest::unsafe_arena_release_order() {
  // @@protoc_insertion_point(field_release:oteldemo.SendOrderConfirmationRequest.order)
  
  ::oteldemo::OrderResult* temp = _impl_.order_;
  _impl_.order_ = nullptr;
  return temp;
}
inline ::oteldemo::OrderResult* SendOrderConfirmationRequest::_internal_mutable_order() {
  
  if (_impl_.order_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::OrderResult>(GetArenaForAllocation());
    _impl_.order_ = p;
  }
  return _impl_.order_;
}
inline ::oteldemo::OrderResult* SendOrderConfirmationRequest::mutable_order() {
  ::oteldemo::OrderResult* _msg = _internal_mutable_order();
  // @@protoc_insertion_point(field_mutable:oteldemo.SendOrderConfirmationRequest.order)
  return _msg;
}
inline void SendOrderConfirmationRequest::set_allocated_order(::oteldemo::OrderResult* order) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.order_;
  }
  if (order) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(order);
    if (message_arena != submessage_arena) {
      order = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.order_ = order;
  // @@protoc_insertion_point(field_set_allocated:oteldemo.SendOrderConfirmationRequest.order)
}

// -------------------------------------------------------------------

// PlaceOrderRequest

// string user_id = 1;
inline void PlaceOrderRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& PlaceOrderRequest::user_id() const {
  // @@protoc_insertion_point(field_get:oteldemo.PlaceOrderRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlaceOrderRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.PlaceOrderRequest.user_id)
}
inline std::string* PlaceOrderRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:oteldemo.PlaceOrderRequest.user_id)
  return _s;
}
inline const std::string& PlaceOrderRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void PlaceOrderRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PlaceOrderRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PlaceOrderRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:oteldemo.PlaceOrderRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void PlaceOrderRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.PlaceOrderRequest.user_id)
}

// string user_currency = 2;
inline void PlaceOrderRequest::clear_user_currency() {
  _impl_.user_currency_.ClearToEmpty();
}
inline const std::string& PlaceOrderRequest::user_currency() const {
  // @@protoc_insertion_point(field_get:oteldemo.PlaceOrderRequest.user_currency)
  return _internal_user_currency();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlaceOrderRequest::set_user_currency(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_currency_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.PlaceOrderRequest.user_currency)
}
inline std::string* PlaceOrderRequest::mutable_user_currency() {
  std::string* _s = _internal_mutable_user_currency();
  // @@protoc_insertion_point(field_mutable:oteldemo.PlaceOrderRequest.user_currency)
  return _s;
}
inline const std::string& PlaceOrderRequest::_internal_user_currency() const {
  return _impl_.user_currency_.Get();
}
inline void PlaceOrderRequest::_internal_set_user_currency(const std::string& value) {
  
  _impl_.user_currency_.Set(value, GetArenaForAllocation());
}
inline std::string* PlaceOrderRequest::_internal_mutable_user_currency() {
  
  return _impl_.user_currency_.Mutable(GetArenaForAllocation());
}
inline std::string* PlaceOrderRequest::release_user_currency() {
  // @@protoc_insertion_point(field_release:oteldemo.PlaceOrderRequest.user_currency)
  return _impl_.user_currency_.Release();
}
inline void PlaceOrderRequest::set_allocated_user_currency(std::string* user_currency) {
  if (user_currency != nullptr) {
    
  } else {
    
  }
  _impl_.user_currency_.SetAllocated(user_currency, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_currency_.IsDefault()) {
    _impl_.user_currency_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.PlaceOrderRequest.user_currency)
}

// .oteldemo.Address address = 3;
inline bool PlaceOrderRequest::_internal_has_address() const {
  return this != internal_default_instance() && _impl_.address_ != nullptr;
}
inline bool PlaceOrderRequest::has_address() const {
  return _internal_has_address();
}
inline void PlaceOrderRequest::clear_address() {
  if (GetArenaForAllocation() == nullptr && _impl_.address_ != nullptr) {
    delete _impl_.address_;
  }
  _impl_.address_ = nullptr;
}
inline const ::oteldemo::Address& PlaceOrderRequest::_internal_address() const {
  const ::oteldemo::Address* p = _impl_.address_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::Address&>(
      ::oteldemo::_Address_default_instance_);
}
inline const ::oteldemo::Address& PlaceOrderRequest::address() const {
  // @@protoc_insertion_point(field_get:oteldemo.PlaceOrderRequest.address)
  return _internal_address();
}
inline void PlaceOrderRequest::unsafe_arena_set_allocated_address(
    ::oteldemo::Address* address) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.address_);
  }
  _impl_.address_ = address;
  if (address) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.PlaceOrderRequest.address)
}
inline ::oteldemo::Address* PlaceOrderRequest::release_address() {
  
  ::oteldemo::Address* temp = _impl_.address_;
  _impl_.address_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::oteldemo::Address* PlaceOrderRequest::unsafe_arena_release_address() {
  // @@protoc_insertion_point(field_release:oteldemo.PlaceOrderRequest.address)
  
  ::oteldemo::Address* temp = _impl_.address_;
  _impl_.address_ = nullptr;
  return temp;
}
inline ::oteldemo::Address* PlaceOrderRequest::_internal_mutable_address() {
  
  if (_impl_.address_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::Address>(GetArenaForAllocation());
    _impl_.address_ = p;
  }
  return _impl_.address_;
}
inline ::oteldemo::Address* PlaceOrderRequest::mutable_address() {
  ::oteldemo::Address* _msg = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:oteldemo.PlaceOrderRequest.address)
  return _msg;
}
inline void PlaceOrderRequest::set_allocated_address(::oteldemo::Address* address) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.address_;
  }
  if (address) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(address);
    if (message_arena != submessage_arena) {
      address = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, address, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.address_ = address;
  // @@protoc_insertion_point(field_set_allocated:oteldemo.PlaceOrderRequest.address)
}

// string email = 5;
inline void PlaceOrderRequest::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& PlaceOrderRequest::email() const {
  // @@protoc_insertion_point(field_get:oteldemo.PlaceOrderRequest.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlaceOrderRequest::set_email(ArgT0&& arg0, ArgT... args) {
 
 _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.PlaceOrderRequest.email)
}
inline std::string* PlaceOrderRequest::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:oteldemo.PlaceOrderRequest.email)
  return _s;
}
inline const std::string& PlaceOrderRequest::_internal_email() const {
  return _impl_.email_.Get();
}
inline void PlaceOrderRequest::_internal_set_email(const std::string& value) {
  
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* PlaceOrderRequest::_internal_mutable_email() {
  
  return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* PlaceOrderRequest::release_email() {
  // @@protoc_insertion_point(field_release:oteldemo.PlaceOrderRequest.email)
  return _impl_.email_.Release();
}
inline void PlaceOrderRequest::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.PlaceOrderRequest.email)
}

// .oteldemo.CreditCardInfo credit_card = 6;
inline bool PlaceOrderRequest::_internal_has_credit_card() const {
  return this != internal_default_instance() && _impl_.credit_card_ != nullptr;
}
inline bool PlaceOrderRequest::has_credit_card() const {
  return _internal_has_credit_card();
}
inline void PlaceOrderRequest::clear_credit_card() {
  if (GetArenaForAllocation() == nullptr && _impl_.credit_card_ != nullptr) {
    delete _impl_.credit_card_;
  }
  _impl_.credit_card_ = nullptr;
}
inline const ::oteldemo::CreditCardInfo& PlaceOrderRequest::_internal_credit_card() const {
  const ::oteldemo::CreditCardInfo* p = _impl_.credit_card_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::CreditCardInfo&>(
      ::oteldemo::_CreditCardInfo_default_instance_);
}
inline const ::oteldemo::CreditCardInfo& PlaceOrderRequest::credit_card() const {
  // @@protoc_insertion_point(field_get:oteldemo.PlaceOrderRequest.credit_card)
  return _internal_credit_card();
}
inline void PlaceOrderRequest::unsafe_arena_set_allocated_credit_card(
    ::oteldemo::CreditCardInfo* credit_card) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.credit_card_);
  }
  _impl_.credit_card_ = credit_card;
  if (credit_card) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.PlaceOrderRequest.credit_card)
}
inline ::oteldemo::CreditCardInfo* PlaceOrderRequest::release_credit_card() {
  
  ::oteldemo::CreditCardInfo* temp = _impl_.credit_card_;
  _impl_.credit_card_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::oteldemo::CreditCardInfo* PlaceOrderRequest::unsafe_arena_release_credit_card() {
  // @@protoc_insertion_point(field_release:oteldemo.PlaceOrderRequest.credit_card)
  
  ::oteldemo::CreditCardInfo* temp = _impl_.credit_card_;
  _impl_.credit_card_ = nullptr;
  return temp;
}
inline ::oteldemo::CreditCardInfo* PlaceOrderRequest::_internal_mutable_credit_card() {
  
  if (_impl_.credit_card_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::CreditCardInfo>(GetArenaForAllocation());
    _impl_.credit_card_ = p;
  }
  return _impl_.credit_card_;
}
inline ::oteldemo::CreditCardInfo* PlaceOrderRequest::mutable_credit_card() {
  ::oteldemo::CreditCardInfo* _msg = _internal_mutable_credit_card();
  // @@protoc_insertion_point(field_mutable:oteldemo.PlaceOrderRequest.credit_card)
  return _msg;
}
inline void PlaceOrderRequest::set_allocated_credit_card(::oteldemo::CreditCardInfo* credit_card) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.credit_card_;
  }
  if (credit_card) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(credit_card);
    if (message_arena != submessage_arena) {
      credit_card = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, credit_card, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.credit_card_ = credit_card;
  // @@protoc_insertion_point(field_set_allocated:oteldemo.PlaceOrderRequest.credit_card)
}

// -------------------------------------------------------------------

// PlaceOrderResponse

// .oteldemo.OrderResult order = 1;
inline bool PlaceOrderResponse::_internal_has_order() const {
  return this != internal_default_instance() && _impl_.order_ != nullptr;
}
inline bool PlaceOrderResponse::has_order() const {
  return _internal_has_order();
}
inline void PlaceOrderResponse::clear_order() {
  if (GetArenaForAllocation() == nullptr && _impl_.order_ != nullptr) {
    delete _impl_.order_;
  }
  _impl_.order_ = nullptr;
}
inline const ::oteldemo::OrderResult& PlaceOrderResponse::_internal_order() const {
  const ::oteldemo::OrderResult* p = _impl_.order_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::OrderResult&>(
      ::oteldemo::_OrderResult_default_instance_);
}
inline const ::oteldemo::OrderResult& PlaceOrderResponse::order() const {
  // @@protoc_insertion_point(field_get:oteldemo.PlaceOrderResponse.order)
  return _internal_order();
}
inline void PlaceOrderResponse::unsafe_arena_set_allocated_order(
    ::oteldemo::OrderResult* order) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.order_);
  }
  _impl_.order_ = order;
  if (order) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.PlaceOrderResponse.order)
}
inline ::oteldemo::OrderResult* PlaceOrderResponse::release_order() {
  
  ::oteldemo::OrderResult* temp = _impl_.order_;
  _impl_.order_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::oteldemo::OrderResult* PlaceOrderResponse::unsafe_arena_release_order() {
  // @@protoc_insertion_point(field_release:oteldemo.PlaceOrderResponse.order)
  
  ::oteldemo::OrderResult* temp = _impl_.order_;
  _impl_.order_ = nullptr;
  return temp;
}
inline ::oteldemo::OrderResult* PlaceOrderResponse::_internal_mutable_order() {
  
  if (_impl_.order_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::OrderResult>(GetArenaForAllocation());
    _impl_.order_ = p;
  }
  return _impl_.order_;
}
inline ::oteldemo::OrderResult* PlaceOrderResponse::mutable_order() {
  ::oteldemo::OrderResult* _msg = _internal_mutable_order();
  // @@protoc_insertion_point(field_mutable:oteldemo.PlaceOrderResponse.order)
  return _msg;
}
inline void PlaceOrderResponse::set_allocated_order(::oteldemo::OrderResult* order) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.order_;
  }
  if (order) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(order);
    if (message_arena != submessage_arena) {
      order = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.order_ = order;
  // @@protoc_insertion_point(field_set_allocated:oteldemo.PlaceOrderResponse.order)
}

// -------------------------------------------------------------------

// AdRequest

// repeated string context_keys = 1;
inline int AdRequest::_internal_context_keys_size() const {
  return _impl_.context_keys_.size();
}
inline int AdRequest::context_keys_size() const {
  return _internal_context_keys_size();
}
inline void AdRequest::clear_context_keys() {
  _impl_.context_keys_.Clear();
}
inline std::string* AdRequest::add_context_keys() {
  std::string* _s = _internal_add_context_keys();
  // @@protoc_insertion_point(field_add_mutable:oteldemo.AdRequest.context_keys)
  return _s;
}
inline const std::string& AdRequest::_internal_context_keys(int index) const {
  return _impl_.context_keys_.Get(index);
}
inline const std::string& AdRequest::context_keys(int index) const {
  // @@protoc_insertion_point(field_get:oteldemo.AdRequest.context_keys)
  return _internal_context_keys(index);
}
inline std::string* AdRequest::mutable_context_keys(int index) {
  // @@protoc_insertion_point(field_mutable:oteldemo.AdRequest.context_keys)
  return _impl_.context_keys_.Mutable(index);
}
inline void AdRequest::set_context_keys(int index, const std::string& value) {
  _impl_.context_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:oteldemo.AdRequest.context_keys)
}
inline void AdRequest::set_context_keys(int index, std::string&& value) {
  _impl_.context_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:oteldemo.AdRequest.context_keys)
}
inline void AdRequest::set_context_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.context_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:oteldemo.AdRequest.context_keys)
}
inline void AdRequest::set_context_keys(int index, const char* value, size_t size) {
  _impl_.context_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:oteldemo.AdRequest.context_keys)
}
inline std::string* AdRequest::_internal_add_context_keys() {
  return _impl_.context_keys_.Add();
}
inline void AdRequest::add_context_keys(const std::string& value) {
  _impl_.context_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:oteldemo.AdRequest.context_keys)
}
inline void AdRequest::add_context_keys(std::string&& value) {
  _impl_.context_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:oteldemo.AdRequest.context_keys)
}
inline void AdRequest::add_context_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.context_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:oteldemo.AdRequest.context_keys)
}
inline void AdRequest::add_context_keys(const char* value, size_t size) {
  _impl_.context_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:oteldemo.AdRequest.context_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AdRequest::context_keys() const {
  // @@protoc_insertion_point(field_list:oteldemo.AdRequest.context_keys)
  return _impl_.context_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AdRequest::mutable_context_keys() {
  // @@protoc_insertion_point(field_mutable_list:oteldemo.AdRequest.context_keys)
  return &_impl_.context_keys_;
}

// -------------------------------------------------------------------

// AdResponse

// repeated .oteldemo.Ad ads = 1;
inline int AdResponse::_internal_ads_size() const {
  return _impl_.ads_.size();
}
inline int AdResponse::ads_size() const {
  return _internal_ads_size();
}
inline void AdResponse::clear_ads() {
  _impl_.ads_.Clear();
}
inline ::oteldemo::Ad* AdResponse::mutable_ads(int index) {
  // @@protoc_insertion_point(field_mutable:oteldemo.AdResponse.ads)
  return _impl_.ads_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::Ad >*
AdResponse::mutable_ads() {
  // @@protoc_insertion_point(field_mutable_list:oteldemo.AdResponse.ads)
  return &_impl_.ads_;
}
inline const ::oteldemo::Ad& AdResponse::_internal_ads(int index) const {
  return _impl_.ads_.Get(index);
}
inline const ::oteldemo::Ad& AdResponse::ads(int index) const {
  // @@protoc_insertion_point(field_get:oteldemo.AdResponse.ads)
  return _internal_ads(index);
}
inline ::oteldemo::Ad* AdResponse::_internal_add_ads() {
  return _impl_.ads_.Add();
}
inline ::oteldemo::Ad* AdResponse::add_ads() {
  ::oteldemo::Ad* _add = _internal_add_ads();
  // @@protoc_insertion_point(field_add:oteldemo.AdResponse.ads)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::Ad >&
AdResponse::ads() const {
  // @@protoc_insertion_point(field_list:oteldemo.AdResponse.ads)
  return _impl_.ads_;
}

// -------------------------------------------------------------------

// Ad

// string redirect_url = 1;
inline void Ad::clear_redirect_url() {
  _impl_.redirect_url_.ClearToEmpty();
}
inline const std::string& Ad::redirect_url() const {
  // @@protoc_insertion_point(field_get:oteldemo.Ad.redirect_url)
  return _internal_redirect_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Ad::set_redirect_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.redirect_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.Ad.redirect_url)
}
inline std::string* Ad::mutable_redirect_url() {
  std::string* _s = _internal_mutable_redirect_url();
  // @@protoc_insertion_point(field_mutable:oteldemo.Ad.redirect_url)
  return _s;
}
inline const std::string& Ad::_internal_redirect_url() const {
  return _impl_.redirect_url_.Get();
}
inline void Ad::_internal_set_redirect_url(const std::string& value) {
  
  _impl_.redirect_url_.Set(value, GetArenaForAllocation());
}
inline std::string* Ad::_internal_mutable_redirect_url() {
  
  return _impl_.redirect_url_.Mutable(GetArenaForAllocation());
}
inline std::string* Ad::release_redirect_url() {
  // @@protoc_insertion_point(field_release:oteldemo.Ad.redirect_url)
  return _impl_.redirect_url_.Release();
}
inline void Ad::set_allocated_redirect_url(std::string* redirect_url) {
  if (redirect_url != nullptr) {
    
  } else {
    
  }
  _impl_.redirect_url_.SetAllocated(redirect_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.redirect_url_.IsDefault()) {
    _impl_.redirect_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.Ad.redirect_url)
}

// string text = 2;
inline void Ad::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& Ad::text() const {
  // @@protoc_insertion_point(field_get:oteldemo.Ad.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Ad::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.Ad.text)
}
inline std::string* Ad::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:oteldemo.Ad.text)
  return _s;
}
inline const std::string& Ad::_internal_text() const {
  return _impl_.text_.Get();
}
inline void Ad::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* Ad::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* Ad::release_text() {
  // @@protoc_insertion_point(field_release:oteldemo.Ad.text)
  return _impl_.text_.Release();
}
inline void Ad::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.Ad.text)
}

// -------------------------------------------------------------------

// Flag

// string name = 1;
inline void Flag::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Flag::name() const {
  // @@protoc_insertion_point(field_get:oteldemo.Flag.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Flag::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.Flag.name)
}
inline std::string* Flag::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:oteldemo.Flag.name)
  return _s;
}
inline const std::string& Flag::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Flag::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Flag::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Flag::release_name() {
  // @@protoc_insertion_point(field_release:oteldemo.Flag.name)
  return _impl_.name_.Release();
}
inline void Flag::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.Flag.name)
}

// string description = 2;
inline void Flag::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Flag::description() const {
  // @@protoc_insertion_point(field_get:oteldemo.Flag.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Flag::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.Flag.description)
}
inline std::string* Flag::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:oteldemo.Flag.description)
  return _s;
}
inline const std::string& Flag::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Flag::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Flag::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Flag::release_description() {
  // @@protoc_insertion_point(field_release:oteldemo.Flag.description)
  return _impl_.description_.Release();
}
inline void Flag::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.Flag.description)
}

// bool enabled = 3;
inline void Flag::clear_enabled() {
  _impl_.enabled_ = false;
}
inline bool Flag::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool Flag::enabled() const {
  // @@protoc_insertion_point(field_get:oteldemo.Flag.enabled)
  return _internal_enabled();
}
inline void Flag::_internal_set_enabled(bool value) {
  
  _impl_.enabled_ = value;
}
inline void Flag::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:oteldemo.Flag.enabled)
}

// -------------------------------------------------------------------

// GetFlagRequest

// string name = 1;
inline void GetFlagRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetFlagRequest::name() const {
  // @@protoc_insertion_point(field_get:oteldemo.GetFlagRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFlagRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.GetFlagRequest.name)
}
inline std::string* GetFlagRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:oteldemo.GetFlagRequest.name)
  return _s;
}
inline const std::string& GetFlagRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetFlagRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetFlagRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetFlagRequest::release_name() {
  // @@protoc_insertion_point(field_release:oteldemo.GetFlagRequest.name)
  return _impl_.name_.Release();
}
inline void GetFlagRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.GetFlagRequest.name)
}

// -------------------------------------------------------------------

// GetFlagResponse

// .oteldemo.Flag flag = 1;
inline bool GetFlagResponse::_internal_has_flag() const {
  return this != internal_default_instance() && _impl_.flag_ != nullptr;
}
inline bool GetFlagResponse::has_flag() const {
  return _internal_has_flag();
}
inline void GetFlagResponse::clear_flag() {
  if (GetArenaForAllocation() == nullptr && _impl_.flag_ != nullptr) {
    delete _impl_.flag_;
  }
  _impl_.flag_ = nullptr;
}
inline const ::oteldemo::Flag& GetFlagResponse::_internal_flag() const {
  const ::oteldemo::Flag* p = _impl_.flag_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::Flag&>(
      ::oteldemo::_Flag_default_instance_);
}
inline const ::oteldemo::Flag& GetFlagResponse::flag() const {
  // @@protoc_insertion_point(field_get:oteldemo.GetFlagResponse.flag)
  return _internal_flag();
}
inline void GetFlagResponse::unsafe_arena_set_allocated_flag(
    ::oteldemo::Flag* flag) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.flag_);
  }
  _impl_.flag_ = flag;
  if (flag) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.GetFlagResponse.flag)
}
inline ::oteldemo::Flag* GetFlagResponse::release_flag() {
  
  ::oteldemo::Flag* temp = _impl_.flag_;
  _impl_.flag_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::oteldemo::Flag* GetFlagResponse::unsafe_arena_release_flag() {
  // @@protoc_insertion_point(field_release:oteldemo.GetFlagResponse.flag)
  
  ::oteldemo::Flag* temp = _impl_.flag_;
  _impl_.flag_ = nullptr;
  return temp;
}
inline ::oteldemo::Flag* GetFlagResponse::_internal_mutable_flag() {
  
  if (_impl_.flag_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::Flag>(GetArenaForAllocation());
    _impl_.flag_ = p;
  }
  return _impl_.flag_;
}
inline ::oteldemo::Flag* GetFlagResponse::mutable_flag() {
  ::oteldemo::Flag* _msg = _internal_mutable_flag();
  // @@protoc_insertion_point(field_mutable:oteldemo.GetFlagResponse.flag)
  return _msg;
}
inline void GetFlagResponse::set_allocated_flag(::oteldemo::Flag* flag) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.flag_;
  }
  if (flag) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(flag);
    if (message_arena != submessage_arena) {
      flag = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flag, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.flag_ = flag;
  // @@protoc_insertion_point(field_set_allocated:oteldemo.GetFlagResponse.flag)
}

// -------------------------------------------------------------------

// CreateFlagRequest

// string name = 1;
inline void CreateFlagRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CreateFlagRequest::name() const {
  // @@protoc_insertion_point(field_get:oteldemo.CreateFlagRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateFlagRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.CreateFlagRequest.name)
}
inline std::string* CreateFlagRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:oteldemo.CreateFlagRequest.name)
  return _s;
}
inline const std::string& CreateFlagRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CreateFlagRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateFlagRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateFlagRequest::release_name() {
  // @@protoc_insertion_point(field_release:oteldemo.CreateFlagRequest.name)
  return _impl_.name_.Release();
}
inline void CreateFlagRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.CreateFlagRequest.name)
}

// string description = 2;
inline void CreateFlagRequest::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& CreateFlagRequest::description() const {
  // @@protoc_insertion_point(field_get:oteldemo.CreateFlagRequest.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateFlagRequest::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.CreateFlagRequest.description)
}
inline std::string* CreateFlagRequest::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:oteldemo.CreateFlagRequest.description)
  return _s;
}
inline const std::string& CreateFlagRequest::_internal_description() const {
  return _impl_.description_.Get();
}
inline void CreateFlagRequest::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateFlagRequest::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateFlagRequest::release_description() {
  // @@protoc_insertion_point(field_release:oteldemo.CreateFlagRequest.description)
  return _impl_.description_.Release();
}
inline void CreateFlagRequest::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.CreateFlagRequest.description)
}

// bool enabled = 3;
inline void CreateFlagRequest::clear_enabled() {
  _impl_.enabled_ = false;
}
inline bool CreateFlagRequest::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool CreateFlagRequest::enabled() const {
  // @@protoc_insertion_point(field_get:oteldemo.CreateFlagRequest.enabled)
  return _internal_enabled();
}
inline void CreateFlagRequest::_internal_set_enabled(bool value) {
  
  _impl_.enabled_ = value;
}
inline void CreateFlagRequest::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:oteldemo.CreateFlagRequest.enabled)
}

// -------------------------------------------------------------------

// CreateFlagResponse

// .oteldemo.Flag flag = 1;
inline bool CreateFlagResponse::_internal_has_flag() const {
  return this != internal_default_instance() && _impl_.flag_ != nullptr;
}
inline bool CreateFlagResponse::has_flag() const {
  return _internal_has_flag();
}
inline void CreateFlagResponse::clear_flag() {
  if (GetArenaForAllocation() == nullptr && _impl_.flag_ != nullptr) {
    delete _impl_.flag_;
  }
  _impl_.flag_ = nullptr;
}
inline const ::oteldemo::Flag& CreateFlagResponse::_internal_flag() const {
  const ::oteldemo::Flag* p = _impl_.flag_;
  return p != nullptr ? *p : reinterpret_cast<const ::oteldemo::Flag&>(
      ::oteldemo::_Flag_default_instance_);
}
inline const ::oteldemo::Flag& CreateFlagResponse::flag() const {
  // @@protoc_insertion_point(field_get:oteldemo.CreateFlagResponse.flag)
  return _internal_flag();
}
inline void CreateFlagResponse::unsafe_arena_set_allocated_flag(
    ::oteldemo::Flag* flag) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.flag_);
  }
  _impl_.flag_ = flag;
  if (flag) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oteldemo.CreateFlagResponse.flag)
}
inline ::oteldemo::Flag* CreateFlagResponse::release_flag() {
  
  ::oteldemo::Flag* temp = _impl_.flag_;
  _impl_.flag_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::oteldemo::Flag* CreateFlagResponse::unsafe_arena_release_flag() {
  // @@protoc_insertion_point(field_release:oteldemo.CreateFlagResponse.flag)
  
  ::oteldemo::Flag* temp = _impl_.flag_;
  _impl_.flag_ = nullptr;
  return temp;
}
inline ::oteldemo::Flag* CreateFlagResponse::_internal_mutable_flag() {
  
  if (_impl_.flag_ == nullptr) {
    auto* p = CreateMaybeMessage<::oteldemo::Flag>(GetArenaForAllocation());
    _impl_.flag_ = p;
  }
  return _impl_.flag_;
}
inline ::oteldemo::Flag* CreateFlagResponse::mutable_flag() {
  ::oteldemo::Flag* _msg = _internal_mutable_flag();
  // @@protoc_insertion_point(field_mutable:oteldemo.CreateFlagResponse.flag)
  return _msg;
}
inline void CreateFlagResponse::set_allocated_flag(::oteldemo::Flag* flag) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.flag_;
  }
  if (flag) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(flag);
    if (message_arena != submessage_arena) {
      flag = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flag, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.flag_ = flag;
  // @@protoc_insertion_point(field_set_allocated:oteldemo.CreateFlagResponse.flag)
}

// -------------------------------------------------------------------

// UpdateFlagRequest

// string name = 1;
inline void UpdateFlagRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& UpdateFlagRequest::name() const {
  // @@protoc_insertion_point(field_get:oteldemo.UpdateFlagRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateFlagRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.UpdateFlagRequest.name)
}
inline std::string* UpdateFlagRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:oteldemo.UpdateFlagRequest.name)
  return _s;
}
inline const std::string& UpdateFlagRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void UpdateFlagRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateFlagRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateFlagRequest::release_name() {
  // @@protoc_insertion_point(field_release:oteldemo.UpdateFlagRequest.name)
  return _impl_.name_.Release();
}
inline void UpdateFlagRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.UpdateFlagRequest.name)
}

// bool enabled = 2;
inline void UpdateFlagRequest::clear_enabled() {
  _impl_.enabled_ = false;
}
inline bool UpdateFlagRequest::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool UpdateFlagRequest::enabled() const {
  // @@protoc_insertion_point(field_get:oteldemo.UpdateFlagRequest.enabled)
  return _internal_enabled();
}
inline void UpdateFlagRequest::_internal_set_enabled(bool value) {
  
  _impl_.enabled_ = value;
}
inline void UpdateFlagRequest::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:oteldemo.UpdateFlagRequest.enabled)
}

// -------------------------------------------------------------------

// UpdateFlagResponse

// -------------------------------------------------------------------

// ListFlagsRequest

// -------------------------------------------------------------------

// ListFlagsResponse

// repeated .oteldemo.Flag flag = 1;
inline int ListFlagsResponse::_internal_flag_size() const {
  return _impl_.flag_.size();
}
inline int ListFlagsResponse::flag_size() const {
  return _internal_flag_size();
}
inline void ListFlagsResponse::clear_flag() {
  _impl_.flag_.Clear();
}
inline ::oteldemo::Flag* ListFlagsResponse::mutable_flag(int index) {
  // @@protoc_insertion_point(field_mutable:oteldemo.ListFlagsResponse.flag)
  return _impl_.flag_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::Flag >*
ListFlagsResponse::mutable_flag() {
  // @@protoc_insertion_point(field_mutable_list:oteldemo.ListFlagsResponse.flag)
  return &_impl_.flag_;
}
inline const ::oteldemo::Flag& ListFlagsResponse::_internal_flag(int index) const {
  return _impl_.flag_.Get(index);
}
inline const ::oteldemo::Flag& ListFlagsResponse::flag(int index) const {
  // @@protoc_insertion_point(field_get:oteldemo.ListFlagsResponse.flag)
  return _internal_flag(index);
}
inline ::oteldemo::Flag* ListFlagsResponse::_internal_add_flag() {
  return _impl_.flag_.Add();
}
inline ::oteldemo::Flag* ListFlagsResponse::add_flag() {
  ::oteldemo::Flag* _add = _internal_add_flag();
  // @@protoc_insertion_point(field_add:oteldemo.ListFlagsResponse.flag)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::oteldemo::Flag >&
ListFlagsResponse::flag() const {
  // @@protoc_insertion_point(field_list:oteldemo.ListFlagsResponse.flag)
  return _impl_.flag_;
}

// -------------------------------------------------------------------

// DeleteFlagRequest

// string name = 1;
inline void DeleteFlagRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DeleteFlagRequest::name() const {
  // @@protoc_insertion_point(field_get:oteldemo.DeleteFlagRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteFlagRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oteldemo.DeleteFlagRequest.name)
}
inline std::string* DeleteFlagRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:oteldemo.DeleteFlagRequest.name)
  return _s;
}
inline const std::string& DeleteFlagRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DeleteFlagRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteFlagRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteFlagRequest::release_name() {
  // @@protoc_insertion_point(field_release:oteldemo.DeleteFlagRequest.name)
  return _impl_.name_.Release();
}
inline void DeleteFlagRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oteldemo.DeleteFlagRequest.name)
}

// -------------------------------------------------------------------

// DeleteFlagResponse

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace oteldemo

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_demo_2eproto
